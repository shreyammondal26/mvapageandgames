<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆ 19 PERFECT GAMES - COMPLETE ULTIMATE EDITION</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            min-height: 100vh; 
            color: white; 
            padding: 20px;
            overflow-x: hidden;
        }
        .container { max-width: 1800px; margin: 0 auto; }
        header { text-align: center; margin-bottom: 40px; }
        h1 { font-size: 2.2em; margin-bottom: 15px; text-shadow: 2px 2px 10px rgba(0,0,0,0.5); }
        
        .games-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); 
            gap: 18px; 
        }
        .game-card { 
            background: rgba(255,255,255,0.2); 
            border-radius: 25px; 
            padding: 20px; 
            text-align: center; 
            cursor: pointer; 
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
            border: 2px solid rgba(255,255,255,0.3);
            position: relative;
            overflow: hidden;
        }
        .game-card::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        .game-card:hover::before {
            left: 100%;
        }
        .game-card:hover { 
            transform: translateY(-15px) scale(1.05); 
            background: rgba(255,255,255,0.3); 
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        }
        .game-icon { font-size: 3em; margin-bottom: 12px; }
        .game-title { font-size: 1.2em; font-weight: bold; margin-bottom: 8px; }
        
        .game-area { 
            display: none; 
            background: rgba(255,255,255,0.2); 
            border-radius: 25px; 
            padding: 25px; 
            margin-top: 20px; 
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255,255,255,0.3);
            text-align: center;
            animation: fadeIn 0.5s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .back-btn { 
            background: #ff6b6b; 
            color: white; 
            border: none; 
            padding: 10px 20px; 
            border-radius: 30px; 
            font-size: 0.9em; 
            cursor: pointer; 
            margin-bottom: 15px;
            transition: all 0.3s;
        }
        .back-btn:hover {
            background: #ff5252;
            transform: scale(1.05);
        }
        button { 
            background: linear-gradient(45deg, #4CAF50, #45a049); 
            color: white; 
            border: none; 
            padding: 10px 20px; 
            border-radius: 30px; 
            font-size: 0.9em; 
            cursor: pointer; 
            margin: 6px; 
            transition: all 0.3s;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .difficulty-btn {
            background: linear-gradient(45deg, #9C27B0, #7B1FA2);
            margin: 5px;
            padding: 6px 15px;
            font-size: 0.8em;
        }
        .difficulty-btn.active {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: #333;
        }
        
        .status { 
            font-size: 1.2em; 
            margin: 15px 0; 
            padding: 15px; 
            background: rgba(255,255,255,0.2); 
            border-radius: 20px; 
            font-weight: bold;
        }
        .score { font-size: 1.6em; color: #FFD700; margin: 12px 0; }
        .stats { 
            display: flex; justify-content: space-around; 
            margin: 12px 0; font-size: 1em; 
        }
        .high-score { color: #FFD700; font-weight: bold; font-size: 1em; margin-top: 6px; }
        
        canvas { 
            border: 5px solid rgba(255,255,255,0.6); 
            border-radius: 20px; 
            display: block; 
            margin: 15px auto; 
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
            background: rgba(0,0,0,0.3);
        }
        
        /* Sound Control */
        .sound-control {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.5em;
            transition: all 0.3s;
        }
        .sound-control:hover {
            background: rgba(0,0,0,0.7);
            transform: scale(1.1);
        }

        /* Game Specific Styles */
        .xo-grid { 
            display: grid; 
            grid-template-columns: repeat(3, 100px); 
            gap: 10px; 
            margin: 20px auto; 
            width: 320px;
            position: relative; 
            height: 320px;
        }
        .xo-cell { 
            width: 100px; height: 100px; 
            background: rgba(255,255,255,0.95); 
            border-radius: 20px; 
            display: flex; align-items: center; justify-content: center; 
            font-size: 3em; font-weight: bold; color: #333; 
            cursor: pointer; 
            transition: all 0.3s;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        }
        .xo-cell:hover:not(.x):not(.o):not(.game-over) { 
            transform: scale(1.05); box-shadow: 0 12px 35px rgba(0,0,0,0.3); 
        }
        .xo-cell.x { color: #e74c3c !important; background: rgba(231,76,60,0.2); }
        .xo-cell.o { color: #3498db !important; background: rgba(52,152,219,0.2); }
        .xo-cell.game-over { cursor: not-allowed; opacity: 0.7; }
        
        .win-line {
            position: absolute;
            height: 8px;
            border-radius: 10px;
            box-shadow: 0 0 20px currentColor;
            transform: scaleX(0);
            transition: transform 0.5s ease-out;
            z-index: 10;
            transform-origin: center;
        }
        .win-line.animate { transform: scaleX(1); }
        .win-line.x { background: #e74c3c; }
        .win-line.o { background: #3498db; }
        
        .memory-container {
            position: relative;
            perspective: 1000px;
        }
        .memory-grid { 
            display: grid; 
            gap: 12px; 
            margin: 20px auto; 
            position: relative;
            transition: all 0.5s ease;
        }
        .easy .memory-grid { 
            grid-template-columns: repeat(4, 80px); 
            width: 350px; 
        }
        .medium .memory-grid { 
            grid-template-columns: repeat(6, 55px); 
            width: 370px; 
        }
        .hard .memory-grid { 
            grid-template-columns: repeat(8, 42px); 
            width: 390px; 
        }
        
        .memory-card { 
            width: 100%; height: 100%; min-height: 80px;
            position: relative;
            cursor: pointer;
            border-radius: 15px;
            transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-style: preserve-3d;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            will-change: transform;
        }
        .memory-card.flipped { 
            transform: rotateY(180deg) scale(0.98); 
        }
        .memory-card.matched { 
            transform: rotateY(180deg) scale(0.92) translateY(-10px);
            cursor: default;
            opacity: 0.8;
            box-shadow: 0 0 30px #FFD700;
        }
        .memory-card.hint {
            animation: hintPulse 1s ease-in-out;
        }
        @keyframes hintPulse {
            0%, 100% { box-shadow: 0 0 20px #00ff88; transform: rotateY(180deg) scale(1.05); }
            50% { box-shadow: 0 0 40px #00ff88; transform: rotateY(180deg) scale(1.15); }
        }
        
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.2em, 3vw, 2em);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }
        .card-back {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52, #e74c3c);
            color: white;
        }
        .card-front {
            background: linear-gradient(135deg, #4ecdc4, #44a08d, #27ae60);
            transform: rotateY(180deg);
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .memory-card.matched .card-front {
            background: linear-gradient(135deg, #f39c12, #e67e22, #d68910);
            box-shadow: inset 0 0 20px rgba(255,215,0,0.4);
        }
        
        .progress-bar {
            width: 100%; height: 8px; background: rgba(0,0,0,0.3);
            border-radius: 5px; margin: 12px 0; overflow: hidden;
        }
        .progress-fill {
            height: 100%; background: linear-gradient(90deg, #00ff88, #FFD700);
            width: 0%; transition: width 0.3s ease; border-radius: 5px;
            box-shadow: 0 0 15px #00ff88;
        }

        .rps-choices {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        .rps-choice {
            font-size: 3.5em;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(255,255,255,0.2);
            padding: 12px;
            border-radius: 20px;
            border: 3px solid transparent;
        }
        .rps-choice:hover {
            transform: scale(1.2) rotate(10deg);
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.5);
        }
        .rps-result {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 20px 0;
            font-size: 1.2em;
        }
        .rps-player-choice, .rps-computer-choice {
            text-align: center;
        }
        .rps-choice-display {
            font-size: 3em;
            margin: 10px 0;
            animation: bounceIn 0.5s;
        }
        @keyframes bounceIn {
            0% { transform: scale(0); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        .rps-vs {
            font-size: 1.6em;
            font-weight: bold;
            color: #FFD700;
        }

        /* 2048 Game Styles */
        .game-2048 {
            display: inline-block;
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 15px;
        }
        .grid-2048 {
            display: grid;
            grid-template-columns: repeat(4, 80px);
            grid-template-rows: repeat(4, 80px);
            gap: 8px;
            background: rgba(255,255,255,0.2);
            padding: 8px;
            border-radius: 10px;
        }
        .tile-2048 {
            background: rgba(255,255,255,0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8em;
            font-weight: bold;
            transition: all 0.2s;
        }
        .tile-2 { background: #eee4da; color: #776e65; }
        .tile-4 { background: #ede0c8; color: #776e65; }
        .tile-8 { background: #f2b179; color: #f9f6f2; }
        .tile-16 { background: #f59563; color: #f9f6f2; }
        .tile-32 { background: #f67c5f; color: #f9f6f2; }
        .tile-64 { background: #f65e3b; color: #f9f6f2; }
        .tile-128 { background: #edcf72; color: #f9f6f2; font-size: 1.5em; }
        .tile-256 { background: #edcc61; color: #f9f6f2; font-size: 1.5em; }
        .tile-512 { background: #edc850; color: #f9f6f2; font-size: 1.5em; }
        .tile-1024 { background: #edc53f; color: #f9f6f2; font-size: 1.2em; }
        .tile-2048 { background: #edc22e; color: #f9f6f2; font-size: 1.2em; }

        /* Minesweeper Styles */
        .minesweeper-grid {
            display: inline-grid;
            gap: 2px;
            background: rgba(255,255,255,0.2);
            padding: 10px;
            border-radius: 10px;
        }
        .mine-cell {
            width: 35px;
            height: 35px;
            background: rgba(255,255,255,0.8);
            border: 2px solid rgba(0,0,0,0.3);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.2s;
        }
        .mine-cell:hover {
            background: rgba(255,255,255,0.9);
            transform: scale(1.05);
        }
        .mine-cell.revealed {
            background: rgba(200,200,200,0.8);
            cursor: default;
        }
        .mine-cell.mine {
            background: #e74c3c;
            color: white;
        }
        .mine-cell.flagged {
            background: #f39c12;
            color: white;
        }
        .mine-cell.count-1 { color: #0000ff; }
        .mine-cell.count-2 { color: #008000; }
        .mine-cell.count-3 { color: #ff0000; }
        .mine-cell.count-4 { color: #000080; }
        .mine-cell.count-5 { color: #800000; }
        .mine-cell.count-6 { color: #008080; }
        .mine-cell.count-7 { color: #000000; }
        .mine-cell.count-8 { color: #808080; }

        /* Simon Says Styles */
        .simon-board {
            display: grid;
            grid-template-columns: repeat(2, 150px);
            grid-template-rows: repeat(2, 150px);
            gap: 10px;
            margin: 20px auto;
            width: 310px;
            height: 310px;
        }
        .simon-button {
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            font-weight: bold;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .simon-red { background: #e74c3c; }
        .simon-blue { background: #3498db; }
        .simon-green { background: #27ae60; }
        .simon-yellow { background: #f39c12; }
        .simon-button.active {
            transform: scale(0.95);
            filter: brightness(1.5);
        }
        .simon-button.disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* Hangman Styles */
        .hangman-container {
            display: flex;
            justify-content: space-around;
            align-items: flex-start;
            margin: 20px 0;
        }
        .hangman-drawing {
            width: 250px;
            height: 250px;
        }
        .hangman-word {
            font-size: 2em;
            letter-spacing: 10px;
            margin: 20px 0;
        }
        .hangman-letters {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
            max-width: 400px;
            margin: 0 auto;
        }
        .letter-btn {
            padding: 10px;
            background: rgba(255,255,255,0.3);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        .letter-btn:hover {
            background: rgba(255,255,255,0.4);
            transform: scale(1.05);
        }
        .letter-btn:disabled {
            background: rgba(0,0,0,0.3);
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* Sudoku Styles */
        .sudoku-container {
            display: inline-block;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 15px;
        }
        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 45px);
            grid-template-rows: repeat(9, 45px);
            gap: 1px;
            background: rgba(255,255,255,0.3);
            border: 3px solid rgba(255,255,255,0.5);
        }
        .sudoku-cell {
            background: rgba(255,255,255,0.9);
            border: 1px solid rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            cursor: pointer;
            transition: all 0.2s;
        }
        .sudoku-cell:hover {
            background: rgba(255,255,255,1);
            transform: scale(1.05);
        }
        .sudoku-cell.selected {
            background: #FFD700;
            color: #333;
        }
        .sudoku-cell.fixed {
            background: rgba(200,200,200,0.9);
            color: #000;
            cursor: default;
        }
        .sudoku-cell:nth-child(3n) {
            border-right: 2px solid rgba(0,0,0,0.5);
        }
        .sudoku-cell:nth-child(n+19):nth-child(-n+27),
        .sudoku-cell:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 2px solid rgba(0,0,0,0.5);
        }

        /* Connect Four Styles */
        .connect4-grid {
            display: grid;
            grid-template-columns: repeat(7, 60px);
            grid-template-rows: repeat(6, 60px);
            gap: 5px;
            background: rgba(255,255,255,0.2);
            padding: 10px;
            border-radius: 15px;
            margin: 20px auto;
        }
        .connect4-cell {
            background: rgba(255,255,255,0.8);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }
        .connect4-cell:hover {
            background: rgba(255,255,255,0.9);
            transform: scale(1.05);
        }
        .connect4-cell.player1 {
            background: #e74c3c;
            animation: dropIn 0.5s ease-out;
        }
        .connect4-cell.player2 {
            background: #f39c12;
            animation: dropIn 0.5s ease-out;
        }
        @keyframes dropIn {
            from { transform: translateY(-300px); }
            to { transform: translateY(0); }
        }

        /* Word Search Styles */
        .wordsearch-container {
            display: inline-block;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 15px;
        }
        .wordsearch-grid {
            display: grid;
            grid-template-columns: repeat(12, 35px);
            grid-template-rows: repeat(12, 35px);
            gap: 2px;
            margin: 20px auto;
        }
        .wordsearch-cell {
            background: rgba(255,255,255,0.8);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #333;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }
        .wordsearch-cell:hover {
            background: rgba(255,255,255,0.9);
            transform: scale(1.05);
        }
        .wordsearch-cell.found {
            background: #FFD700;
            color: #333;
        }
        .wordsearch-cell.selecting {
            background: rgba(255,215,0,0.5);
        }
        .word-list {
            margin: 20px 0;
            font-size: 1.2em;
        }
        .word-item {
            display: inline-block;
            margin: 5px 10px;
            padding: 5px 15px;
            background: rgba(255,255,255,0.2);
            border-radius: 20px;
            transition: all 0.3s;
        }
        .word-item.found {
            background: #FFD700;
            color: #333;
            text-decoration: line-through;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            animation: fadeIn 0.3s ease;
        }
        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #667eea, #764ba2);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 500px;
            width: 90%;
        }
        .modal-title {
            font-size: 2em;
            margin-bottom: 15px;
            color: #FFD700;
        }
        .modal-message {
            font-size: 1.2em;
            margin-bottom: 20px;
        }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        .modal-close {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1.1em;
            transition: all 0.3s;
        }
        .modal-close:hover {
            background: #45a049;
            transform: scale(1.05);
        }
        .modal-cancel {
            background: #f44336;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1.1em;
            transition: all 0.3s;
        }
        .modal-cancel:hover {
            background: #da190b;
            transform: scale(1.05);
        }

        /* Flappy Bird Game Over Overlay */
        .flappy-game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            z-index: 10;
        }
        .flappy-game-over h3 {
            font-size: 2em;
            color: #FFD700;
            margin-bottom: 15px;
        }
        .flappy-game-over p {
            font-size: 1.2em;
            margin-bottom: 20px;
        }
        .flappy-start-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s;
        }
        .flappy-start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div class="sound-control" id="soundToggle" onclick="toggleSound()">üîä</div>
    
    <div class="container">
        <header>
            <h1>üéÆ 19 PERFECT GAMES - ULTIMATE EDITION</h1>
            <p style="font-size: 0.8em;">‚ùå‚≠ï XO ‚Ä¢ üêç Snake ‚Ä¢ üß† Memory ‚Ä¢ üéÆ Breakout ‚Ä¢ ‚úÇÔ∏è RPS ‚Ä¢ üî´ Shooter ‚Ä¢ üèéÔ∏è Racer ‚Ä¢ üèì Pong ‚Ä¢ üß© Tetris ‚Ä¢ üê¶ Flappy ‚Ä¢ ü¶ï Dino ‚Ä¢ üî¢ 2048 ‚Ä¢ üí£ Minesweeper ‚Ä¢ üéµ Simon ‚Ä¢ üéØ Hangman ‚Ä¢ üî§ Sudoku ‚Ä¢ üî¥ Connect4 ‚Ä¢ üîç Word Search</p>
        </header>

        <div class="games-grid" id="gamesGrid">
            <div class="game-card" onclick="confirmGameStart('xo')">
                <div class="game-icon">‚ùå‚≠ï</div>
                <div class="game-title">XO Game</div>
            </div>
            <div class="game-card" onclick="confirmGameStart('snake')">
                <div class="game-icon">üêçüçé</div>
                <div class="game-title">Snake</div>
            </div>
            <div class="game-card" onclick="confirmGameStart('memory')">
                <div class="game-icon">üß†‚ú®</div>
                <div class="game-title">Memory Pro</div>
            </div>
            <div class="game-card" onclick="confirmGameStart('breakout')">
                <div class="game-icon">üéÆ</div>
                <div class="game-title">Breakout</div>
            </div>
            <div class="game-card" onclick="confirmGameStart('rps')">
                <div class="game-icon">‚úÇÔ∏èüìÑ</div>
                <div class="game-title">Rock Paper Scissors</div>
            </div>
            <div class="game-card" onclick="confirmGameStart('shooter')">
                <div class="game-icon">üî´</div>
                <div class="game-title">Space Shooter</div>
            </div>
            <div class="game-card" onclick="confirmGameStart('car')">
                <div class="game-icon">üèéÔ∏è</div>
                <div class="game-title">Car Racer</div>
            </div>
            <div class="game-card" onclick="confirmGameStart('pong')">
                <div class="game-icon">üèì</div>
                <div class="game-title">Pong</div>
            </div>
            <div class="game-card" onclick="confirmGameStart('tetris')">
                <div class="game-icon">üß©</div>
                <div class="game-title">Tetris</div>
            </div>
            <div class="game-card" onclick="confirmGameStart('flappy')">
                <div class="game-icon">üê¶</div>
                <div class="game-title">Flappy Bird</div>
            </div>
            <div class="game-card" onclick="confirmGameStart('dino')">
                <div class="game-icon">ü¶ï</div>
                <div class="game-title">Chrome Dino</div>
            </div>
            <div class="game-card" onclick="confirmGameStart('2048')">
                <div class="game-icon">üî¢</div>
                <div class="game-title">2048</div>
            </div>
            <div class="game-card" onclick="confirmGameStart('minesweeper')">
                <div class="game-icon">üí£</div>
                <div class="game-title">Minesweeper</div>
            </div>
            <div class="game-card" onclick="confirmGameStart('simon')">
                <div class="game-icon">üéµ</div>
                <div class="game-title">Simon Says</div>
            </div>
            <div class="game-card" onclick="confirmGameStart('hangman')">
                <div class="game-icon">üéØ</div>
                <div class="game-title">Hangman</div>
            </div>
            <div class="game-card" onclick="confirmGameStart('sudoku')">
                <div class="game-icon">üî§</div>
                <div class="game-title">Sudoku</div>
            </div>
            <div class="game-card" onclick="confirmGameStart('connect4')">
                <div class="game-icon">üî¥</div>
                <div class="game-title">Connect Four</div>
            </div>
            <div class="game-card" onclick="confirmGameStart('wordsearch')">
                <div class="game-icon">üîç</div>
                <div class="game-title">Word Search</div>
            </div>
        </div>

        <!-- XO GAME -->
        <div id="xoGame" class="game-area">
            <button class="back-btn" onclick="showGames()">‚Üê BACK</button>
            <h2>‚ùå VS ‚≠ï</h2>
            <div class="status" id="xoStatus">X's TURN</div>
            <div class="xo-grid" id="xoGrid">
                <div class="xo-cell" onclick="playXO(0)"></div>
                <div class="xo-cell" onclick="playXO(1)"></div>
                <div class="xo-cell" onclick="playXO(2)"></div>
                <div class="xo-cell" onclick="playXO(3)"></div>
                <div class="xo-cell" onclick="playXO(4)"></div>
                <div class="xo-cell" onclick="playXO(5)"></div>
                <div class="xo-cell" onclick="playXO(6)"></div>
                <div class="xo-cell" onclick="playXO(7)"></div>
                <div class="xo-cell" onclick="playXO(8)"></div>
            </div>
            <button onclick="resetXO()">üîÑ NEW GAME</button>
            <div class="high-score" id="xoHighScore">XO WINS: 0</div>
        </div>

        <!-- SNAKE GAME -->
        <div id="snakeGame" class="game-area">
            <button class="back-btn" onclick="showGames()">‚Üê BACK</button>
            <h2>üêç SNAKE</h2>
            <div class="score" id="snakeScore">SCORE: 0</div>
            <canvas id="snakeCanvas" width="400" height="400"></canvas>
            <div class="status">ARROW KEYS ‚Üë‚Üì‚Üê‚Üí</div>
            <div class="high-score" id="snakeHighScore">HIGH: 0</div>
        </div>

        <!-- MEMORY GAME -->
        <div id="memoryGame" class="game-area">
            <button class="back-btn" onclick="showGames()">‚Üê BACK</button>
            <h2>üß† MEMORY PRO</h2>
            
            <div class="stats">
                <div>Difficulty: <span id="currentDifficulty">EASY</span></div>
                <div>Goal: <span id="matchGoal">8</span> pairs</div>
                <div>Time: <span id="gameTimer">0</span>s</div>
            </div>
            
            <div class="score" id="memoryScore">MATCHES: 0/8</div>
            
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            
            <div class="memory-container easy" id="memoryContainer">
                <div class="memory-grid" id="memoryGrid"></div>
            </div>
            
            <div style="margin: 15px 0;">
                <button class="difficulty-btn active" onclick="setDifficulty('easy')">üü¢ EASY</button>
                <button class="difficulty-btn" onclick="setDifficulty('medium')">üü° MEDIUM</button>
                <button class="difficulty-btn" onclick="setDifficulty('hard')">üî¥ HARD</button>
                <button onclick="giveHint()">üí° HINT</button>
            </div>
            
            <button onclick="resetMemory()">üîÑ NEW GAME</button>
            <div class="high-score" id="memoryHighScore">BEST TIME: --</div>
        </div>

        <!-- BREAKOUT -->
        <div id="breakoutGame" class="game-area">
            <button class="back-btn" onclick="showGames()">‚Üê BACK</button>
            <h2>üéÆ BREAKOUT</h2>
            <div class="score" id="breakoutScore">SCORE: 0 | LIVES: 3</div>
            <canvas id="breakoutCanvas" width="600" height="400"></canvas>
            <div class="status">MOUSE = Paddle | SPACE = PAUSE</div>
            <div class="high-score" id="breakoutHighScore">HIGH: 0</div>
        </div>

        <!-- ROCK PAPER SCISSORS -->
        <div id="rpsGame" class="game-area">
            <button class="back-btn" onclick="showGames()">‚Üê BACK</button>
            <h2>‚úÇÔ∏è ROCK PAPER SCISSORS</h2>
            <div class="score" id="rpsScore">WINS: 0 | LOSSES: 0 | DRAWS: 0</div>
            
            <div class="rps-choices">
                <div class="rps-choice" onclick="playRPS('rock')">ü™®</div>
                <div class="rps-choice" onclick="playRPS('paper')">üìÑ</div>
                <div class="rps-choice" onclick="playRPS('scissors')">‚úÇÔ∏è</div>
            </div>
            
            <div class="rps-result" id="rpsResult" style="display:none;">
                <div class="rps-player-choice">
                    <div>YOU</div>
                    <div class="rps-choice-display" id="playerChoice"></div>
                </div>
                <div class="rps-vs">VS</div>
                <div class="rps-computer-choice">
                    <div>COMPUTER</div>
                    <div class="rps-choice-display" id="computerChoice"></div>
                </div>
            </div>
            
            <div class="status" id="rpsStatus">MAKE YOUR CHOICE!</div>
            <button onclick="resetRPS()">üîÑ RESET SCORE</button>
            <div class="high-score" id="rpsHighScore">WIN STREAK: 0</div>
        </div>

        <!-- SHOOTER GAME -->
        <div id="shooterGame" class="game-area">
            <button class="back-btn" onclick="showGames()">‚Üê BACK</button>
            <h2>üî´ SPACE SHOOTER</h2>
            <div class="score" id="shooterScore">SCORE: 0 | LEVEL: 1</div>
            <canvas id="shooterCanvas" width="700" height="500"></canvas>
            <div class="status">CLICK TO SHOOT | MOVE MOUSE TO AIM</div>
            <div class="high-score" id="shooterHighScore">HIGH: 0</div>
        </div>

        <!-- CAR GAME -->
        <div id="carGame" class="game-area">
            <button class="back-btn" onclick="showGames()">‚Üê BACK</button>
            <h2>üèéÔ∏è CAR RACER</h2>
            <div class="score" id="carScore">DISTANCE: 0m | SPEED: 0km/h</div>
            <canvas id="carCanvas" width="350" height="500"></canvas>
            <div class="status">‚Üê ‚Üí ARROW KEYS TO MOVE</div>
            <div class="high-score" id="carHighScore">BEST DISTANCE: 0m</div>
        </div>

        <!-- PONG GAME -->
        <div id="pongGame" class="game-area">
            <button class="back-btn" onclick="showGames()">‚Üê BACK</button>
            <h2>üèì PONG</h2>
            <div class="score" id="pongScore">PLAYER: 0 | COMPUTER: 0</div>
            <canvas id="pongCanvas" width="600" height="400"></canvas>
            <div class="status">W/S KEYS OR MOUSE TO MOVE</div>
            <div class="high-score" id="pongHighScore">HIGH: 0</div>
        </div>

        <!-- TETRIS GAME -->
        <div id="tetrisGame" class="game-area">
            <button class="back-btn" onclick="showGames()">‚Üê BACK</button>
            <h2>üß© TETRIS</h2>
            <div class="score" id="tetrisScore">SCORE: 0 | LINES: 0</div>
            <canvas id="tetrisCanvas" width="300" height="600"></canvas>
            <div class="status">‚Üê ‚Üí TO MOVE | ‚Üë TO ROTATE | ‚Üì TO DROP</div>
            <div class="high-score" id="tetrisHighScore">HIGH: 0</div>
        </div>

        <!-- FLAPPY BIRD GAME -->
        <div id="flappyGame" class="game-area">
            <button class="back-btn" onclick="showGames()">‚Üê BACK</button>
            <h2>üê¶ FLAPPY BIRD</h2>
            <div class="score" id="flappyScore">SCORE: 0</div>
            <div style="position: relative; display: inline-block;">
                <canvas id="flappyCanvas" width="400" height="600"></canvas>
                <div id="flappyGameOver" class="flappy-game-over" style="display: none;">
                    <h3>Game Over!</h3>
                    <p>Score: <span id="flappyFinalScore">0</span></p>
                    <button class="flappy-start-btn" onclick="startFlappyGame()">START GAME</button>
                </div>
            </div>
            <div class="status">CLICK OR SPACE TO JUMP</div>
            <div class="high-score" id="flappyHighScore">HIGH: 0</div>
        </div>

        <!-- DINO GAME -->
        <div id="dinoGame" class="game-area">
            <button class="back-btn" onclick="showGames()">‚Üê BACK</button>
            <h2>ü¶ï CHROME DINO</h2>
            <div class="score" id="dinoScore">SCORE: 0</div>
            <canvas id="dinoCanvas" width="800" height="400"></canvas>
            <div class="status">SPACE OR CLICK TO JUMP</div>
            <div class="high-score" id="dinoHighScore">HIGH: 0</div>
        </div>

        <!-- 2048 GAME -->
        <div id="2048Game" class="game-area">
            <button class="back-btn" onclick="showGames()">‚Üê BACK</button>
            <h2>üî¢ 2048</h2>
            <div class="score" id="2048Score">SCORE: 0 | BEST: 0</div>
            <div class="game-2048">
                <div class="grid-2048" id="2048Grid"></div>
            </div>
            <div class="status">USE ARROW KEYS TO MOVE TILES</div>
            <button onclick="reset2048()">üîÑ NEW GAME</button>
            <div class="high-score" id="2048HighScore">HIGH: 0</div>
        </div>

        <!-- MINESWEEPER GAME -->
        <div id="minesweeperGame" class="game-area">
            <button class="back-btn" onclick="showGames()">‚Üê BACK</button>
            <h2>üí£ MINESWEEPER</h2>
            <div class="score" id="minesweeperScore">MINES: 10 | FLAGS: 0</div>
            <div class="minesweeper-grid" id="minesweeperGrid"></div>
            <div class="status">LEFT CLICK TO REVEAL | RIGHT CLICK TO FLAG</div>
            <button onclick="resetMinesweeper()">üîÑ NEW GAME</button>
            <div class="high-score" id="minesweeperHighScore">BEST TIME: --</div>
        </div>

        <!-- SIMON SAYS GAME -->
        <div id="simonGame" class="game-area">
            <button class="back-btn" onclick="showGames()">‚Üê BACK</button>
            <h2>üéµ SIMON SAYS</h2>
            <div class="score" id="simonScore">LEVEL: 0 | BEST: 0</div>
            <div class="simon-board">
                <div class="simon-button simon-red" data-color="red" onclick="simonClick('red')">R</div>
                <div class="simon-button simon-blue" data-color="blue" onclick="simonClick('blue')">B</div>
                <div class="simon-button simon-green" data-color="green" onclick="simonClick('green')">G</div>
                <div class="simon-button simon-yellow" data-color="yellow" onclick="simonClick('yellow')">Y</div>
            </div>
            <div class="status" id="simonStatus">PRESS START TO BEGIN</div>
            <button onclick="startSimon()">üéÆ START</button>
            <div class="high-score" id="simonHighScore">BEST LEVEL: 0</div>
        </div>

        <!-- HANGMAN GAME -->
        <div id="hangmanGame" class="game-area">
            <button class="back-btn" onclick="showGames()">‚Üê BACK</button>
            <h2>üéØ HANGMAN</h2>
            <div class="score" id="hangmanScore">WINS: 0 | LOSSES: 0</div>
            <div class="hangman-container">
                <canvas id="hangmanCanvas" class="hangman-drawing" width="250" height="250"></canvas>
                <div>
                    <div class="hangman-word" id="hangmanWord">_ _ _ _ _</div>
                    <div class="hangman-letters" id="hangmanLetters"></div>
                </div>
            </div>
            <div class="status" id="hangmanStatus">GUESS THE WORD!</div>
            <button onclick="resetHangman()">üîÑ NEW WORD</button>
            <div class="high-score" id="hangmanHighScore">WIN STREAK: 0</div>
        </div>

        <!-- SUDOKU GAME -->
        <div id="sudokuGame" class="game-area">
            <button class="back-btn" onclick="showGames()">‚Üê BACK</button>
            <h2>üî§ SUDOKU</h2>
            <div class="score" id="sudokuScore">MISTAKES: 0/3</div>
            <div class="sudoku-container">
                <div class="sudoku-grid" id="sudokuGrid"></div>
            </div>
            <div class="status">CLICK A CELL THEN TYPE 1-9</div>
            <button onclick="resetSudoku()">üîÑ NEW GAME</button>
            <div class="high-score" id="sudokuHighScore">BEST TIME: --</div>
        </div>

        <!-- CONNECT FOUR GAME -->
        <div id="connect4Game" class="game-area">
            <button class="back-btn" onclick="showGames()">‚Üê BACK</button>
            <h2>üî¥ CONNECT FOUR</h2>
            <div class="score" id="connect4Score">RED: 0 | YELLOW: 0</div>
            <div class="connect4-grid" id="connect4Grid"></div>
            <div class="status" id="connect4Status">RED'S TURN</div>
            <button onclick="resetConnect4()">üîÑ NEW GAME</button>
            <div class="high-score" id="connect4HighScore">RED WINS: 0</div>
        </div>

        <!-- WORD SEARCH GAME -->
        <div id="wordsearchGame" class="game-area">
            <button class="back-btn" onclick="showGames()">‚Üê BACK</button>
            <h2>üîç WORD SEARCH</h2>
            <div class="score" id="wordsearchScore">FOUND: 0/8</div>
            <div class="wordsearch-container">
                <div class="wordsearch-grid" id="wordsearchGrid"></div>
                <div class="word-list" id="wordList"></div>
            </div>
            <div class="status">DRAG TO SELECT WORDS</div>
            <button onclick="resetWordSearch()">üîÑ NEW PUZZLE</button>
            <div class="high-score" id="wordsearchHighScore">BEST TIME: --</div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmModal" class="modal">
        <div class="modal-content">
            <div class="modal-title" id="confirmTitle">Start Game?</div>
            <div class="modal-message" id="confirmMessage">Are you ready to play?</div>
            <div class="modal-buttons">
                <button class="modal-close" id="confirmStart">START</button>
                <button class="modal-cancel" id="confirmCancel">CANCEL</button>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="gameModal" class="modal">
        <div class="modal-content">
            <div class="modal-title" id="modalTitle">Game Over</div>
            <div class="modal-message" id="modalMessage">Message</div>
            <button class="modal-close" onclick="closeModal()">OK</button>
        </div>
    </div>

    <script>
        // Sound System
        let soundEnabled = true;
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (!soundEnabled) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch(type) {
                case 'hit':
                    oscillator.frequency.value = 200;
                    oscillator.type = 'square';
                    gainNode.gain.value = 0.1;
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'score':
                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    gainNode.gain.value = 0.1;
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                case 'gameOver':
                    oscillator.frequency.value = 100;
                    oscillator.type = 'sawtooth';
                    gainNode.gain.value = 0.1;
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;
                case 'jump':
                    oscillator.frequency.value = 400;
                    oscillator.type = 'sine';
                    gainNode.gain.value = 0.1;
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'move':
                    oscillator.frequency.value = 300;
                    oscillator.type = 'triangle';
                    gainNode.gain.value = 0.05;
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.05);
                    break;
                case 'win':
                    oscillator.frequency.value = 600;
                    oscillator.type = 'sine';
                    gainNode.gain.value = 0.1;
                    oscillator.start();
                    oscillator.frequency.linearRampToValueAtTime(1200, audioContext.currentTime + 0.2);
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                case 'simon':
                    const frequencies = {red: 329.63, blue: 440, green: 261.63, yellow: 493.88};
                    oscillator.frequency.value = frequencies[type] || 440;
                    oscillator.type = 'sine';
                    gainNode.gain.value = 0.2;
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
            }
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundToggle').textContent = soundEnabled ? 'üîä' : 'üîá';
            if (soundEnabled) playSound('score');
        }

        let currentGame = '';
        let pendingGame = '';
        
        // Game states
        let highScores = {
            xo: 0, snake: 0, memory: {easy:999, medium:999, hard:999}, 
            breakout: 0, rps: 0, shooter: 0, car: 0, pong: 0, tetris: 0, 
            flappy: 0, dino: 0, '2048': 0, minesweeper: 999, simon: 0,
            hangman: 0, sudoku: 999, connect4: 0, wordsearch: 999
        };
        
        // Load high scores from localStorage
        try {
            const saved = localStorage.getItem('gameHighScores');
            if (saved) highScores = JSON.parse(saved);
        } catch (e) {
            console.error('Failed to load high scores:', e);
        }
        
        let snake = { x: 20, y: 20, dx: 1, dy: 0, cells: [], maxCells: 4, foodX: 30, foodY: 20, score: 0 };
        let xo = { board: Array(9).fill(''), turn: 'X', winner: null, winLine: null, moves: 0 };
        let memory = { cards: [], flipped: [], matches: 0, totalPairs: 8, isChecking: false, difficulty: 'easy' };
        let breakout = {
            ball: { x: 300, y: 200, dx: 4, dy: -4, radius: 8 },
            paddle: { x: 250, width: 100, height: 20, y: 360 },
            bricks: [], score: 0, lives: 3, gameRunning: false, paused: false
        };
        let rps = { wins: 0, losses: 0, draws: 0, streak: 0, maxStreak: 0 };
        let shooter = {
            player: { x: 350, y: 400, width: 50, height: 50 },
            bullets: [],
            enemies: [],
            score: 0,
            level: 1,
            gameRunning: false
        };
        let car = {
            x: 175, y: 350, width: 40, height: 60, speed: 0,
            obstacles: [], distance: 0, maxSpeed: 5, gameRunning: false
        };
        let pong = {
            ball: { x: 300, y: 200, dx: 4, dy: 3, radius: 8 },
            playerPaddle: { x: 30, y: 150, width: 15, height: 100, dy: 0 },
            computerPaddle: { x: 555, y: 150, width: 15, height: 100, dy: 0 },
            playerScore: 0,
            computerScore: 0,
            gameRunning: false
        };
        let tetris = {
            board: Array(20).fill().map(() => Array(10).fill(0)),
            currentPiece: null,
            currentX: 0,
            currentY: 0,
            score: 0,
            lines: 0,
            gameRunning: false,
            dropCounter: 0,
            lastTime: 0
        };
        let flappy = {
            bird: { x: 100, y: 300, velocity: 0, radius: 15 },
            pipes: [],
            score: 0,
            gameRunning: false,
            gameStarted: false
        };
        let dino = {
            dino: { x: 50, y: 300, width: 40, height: 50, velocity: 0, jumping: false },
            obstacles: [],
            score: 0,
            gameRunning: false,
            speed: 5,
            gravity: 0.8,
            jumpPower: -15
        };
        let game2048 = {
            board: Array(4).fill().map(() => Array(4).fill(0)),
            score: 0,
            best: 0,
            gameRunning: true
        };
        let minesweeper = {
            board: [],
            revealed: [],
            flagged: [],
            mines: [],
            gameOver: false,
            startTime: null,
            rows: 9,
            cols: 9,
            mineCount: 10
        };
        let simon = {
            sequence: [],
            playerSequence: [],
            level: 0,
            isPlaying: false,
            canClick: false
        };
        let hangman = {
            words: ['JAVASCRIPT', 'PYTHON', 'CODING', 'GAMING', 'PUZZLE', 'COMPUTER', 'ALGORITHM', 'FUNCTION'],
            currentWord: '',
            guessedLetters: [],
            wrongGuesses: 0,
            wins: 0,
            losses: 0,
            streak: 0
        };
        let sudoku = {
            board: [],
            solution: [],
            selectedCell: null,
            mistakes: 0,
            startTime: null
        };
        let connect4 = {
            board: Array(6).fill().map(() => Array(7).fill(0)),
            currentPlayer: 1,
            redWins: 0,
            yellowWins: 0,
            gameRunning: true
        };
        let wordsearch = {
            grid: [],
            words: ['CODING', 'GAMES', 'PUZZLE', 'PLAYER', 'SCORE', 'WIN', 'LEVEL', 'FUN'],
            foundWords: [],
            selecting: false,
            selectedCells: [],
            startTime: null
        };
        
        let snakeInterval, breakoutInterval, memoryStartTime, gameTimerInterval, shooterInterval, carInterval, pongInterval, tetrisInterval, flappyInterval, dinoInterval, minesweeperInterval, sudokuInterval;
        let memoryDifficulty = 'easy';

        // Tetris pieces
        const tetrisPieces = [
            [[1,1,1,1]],  // I
            [[1,1],[1,1]],  // O
            [[0,1,0],[1,1,1]],  // T
            [[1,0,0],[1,1,1]],  // L
            [[0,0,1],[1,1,1]],  // J
            [[0,1,1],[1,1,0]],  // S
            [[1,1,0],[0,1,1]]   // Z
        ];

        // Modal functions
        function showModal(title, message) {
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalMessage').textContent = message;
            document.getElementById('gameModal').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('gameModal').style.display = 'none';
        }

        // Confirmation modal functions
        function confirmGameStart(game) {
            pendingGame = game;
            const gameNames = {
                'xo': 'XO Game',
                'snake': 'Snake',
                'memory': 'Memory Pro',
                'breakout': 'Breakout',
                'rps': 'Rock Paper Scissors',
                'shooter': 'Space Shooter',
                'car': 'Car Racer',
                'pong': 'Pong',
                'tetris': 'Tetris',
                'flappy': 'Flappy Bird',
                'dino': 'Chrome Dino',
                '2048': '2048',
                'minesweeper': 'Minesweeper',
                'simon': 'Simon Says',
                'hangman': 'Hangman',
                'sudoku': 'Sudoku',
                'connect4': 'Connect Four',
                'wordsearch': 'Word Search'
            };
            
            document.getElementById('confirmTitle').textContent = `Start ${gameNames[game]}?`;
            document.getElementById('confirmMessage').textContent = 'Are you ready to play?';
            document.getElementById('confirmModal').style.display = 'block';
            
            document.getElementById('confirmStart').onclick = () => {
                document.getElementById('confirmModal').style.display = 'none';
                showGame(pendingGame);
            };
            
            document.getElementById('confirmCancel').onclick = () => {
                document.getElementById('confirmModal').style.display = 'none';
            };
        }

        // Navigation
        function showGame(game) {
            clearAllIntervals();
            
            document.querySelectorAll('.game-area').forEach(area => area.style.display = 'none');
            document.getElementById('gamesGrid').style.display = 'none';
            document.getElementById(game + 'Game').style.display = 'block';
            currentGame = game;
            
            if (game === 'xo') initXO();
            if (game === 'snake') initSnake();
            if (game === 'memory') initMemory();
            if (game === 'breakout') initBreakout();
            if (game === 'rps') initRPS();
            if (game === 'shooter') initShooter();
            if (game === 'car') initCar();
            if (game === 'pong') initPong();
            if (game === 'tetris') initTetris();
            if (game === 'flappy') initFlappy();
            if (game === 'dino') initDino();
            if (game === '2048') init2048();
            if (game === 'minesweeper') initMinesweeper();
            if (game === 'simon') initSimon();
            if (game === 'hangman') initHangman();
            if (game === 'sudoku') initSudoku();
            if (game === 'connect4') initConnect4();
            if (game === 'wordsearch') initWordSearch();
            updateHighScores();
        }

        function showGames() {
            clearAllIntervals();
            document.querySelectorAll('.game-area').forEach(area => area.style.display = 'none');
            document.getElementById('gamesGrid').style.display = 'grid';
            currentGame = '';
        }

        function clearAllIntervals() {
            if (snakeInterval) clearInterval(snakeInterval);
            if (breakoutInterval) clearInterval(breakoutInterval);
            if (gameTimerInterval) clearInterval(gameTimerInterval);
            if (shooterInterval) clearInterval(shooterInterval);
            if (carInterval) clearInterval(carInterval);
            if (pongInterval) clearInterval(pongInterval);
            if (tetrisInterval) clearInterval(tetrisInterval);
            if (flappyInterval) clearInterval(flappyInterval);
            if (dinoInterval) clearInterval(dinoInterval);
            if (minesweeperInterval) clearInterval(minesweeperInterval);
            if (sudokuInterval) clearInterval(sudokuInterval);
            snakeInterval = null;
            breakoutInterval = null;
            gameTimerInterval = null;
            shooterInterval = null;
            carInterval = null;
            pongInterval = null;
            tetrisInterval = null;
            flappyInterval = null;
            dinoInterval = null;
            minesweeperInterval = null;
            sudokuInterval = null;
        }

        // High score management
        function updateHighScores() {
            document.getElementById('xoHighScore').textContent = `XO WINS: ${highScores.xo}`;
            document.getElementById('snakeHighScore').textContent = `HIGH: ${highScores.snake}`;
            document.getElementById('breakoutHighScore').textContent = `HIGH: ${highScores.breakout}`;
            document.getElementById('rpsHighScore').textContent = `WIN STREAK: ${highScores.rps}`;
            document.getElementById('shooterHighScore').textContent = `HIGH: ${highScores.shooter}`;
            document.getElementById('carHighScore').textContent = `BEST DISTANCE: ${highScores.car}m`;
            document.getElementById('pongHighScore').textContent = `HIGH: ${highScores.pong}`;
            document.getElementById('tetrisHighScore').textContent = `HIGH: ${highScores.tetris}`;
            document.getElementById('flappyHighScore').textContent = `HIGH: ${highScores.flappy}`;
            document.getElementById('dinoHighScore').textContent = `HIGH: ${highScores.dino}`;
            document.getElementById('2048HighScore').textContent = `HIGH: ${highScores['2048']}`;
            document.getElementById('minesweeperHighScore').textContent = `BEST TIME: ${highScores.minesweeper === 999 ? '--' : highScores.minesweeper + 's'}`;
            document.getElementById('simonHighScore').textContent = `BEST LEVEL: ${highScores.simon}`;
            document.getElementById('hangmanHighScore').textContent = `WIN STREAK: ${highScores.hangman}`;
            document.getElementById('sudokuHighScore').textContent = `BEST TIME: ${highScores.sudoku === 999 ? '--' : highScores.sudoku + 's'}`;
            document.getElementById('connect4HighScore').textContent = `RED WINS: ${highScores.connect4}`;
            document.getElementById('wordsearchHighScore').textContent = `BEST TIME: ${highScores.wordsearch === 999 ? '--' : highScores.wordsearch + 's'}`;
            
            const memHigh = document.getElementById('memoryHighScore');
            if (memHigh) {
                const time = highScores.memory[memoryDifficulty];
                memHigh.textContent = `${memoryDifficulty.toUpperCase()} BEST: ${time === 999 ? '--' : time + 's'}`;
            }
        }

        function saveHighScore(game, score) {
            try {
                if (game === 'xo') {
                    highScores.xo = (highScores.xo || 0) + 1;
                } else if (game === 'memory') {
                    const time = Math.floor((Date.now() - memoryStartTime) / 1000);
                    if (time < highScores.memory[memoryDifficulty] || highScores.memory[memoryDifficulty] === 999) {
                        highScores.memory[memoryDifficulty] = time;
                    }
                    score = time;
                } else if (game === 'rps') {
                    if (rps.streak > highScores.rps) highScores.rps = rps.streak;
                } else if (game === 'hangman') {
                    if (hangman.streak > highScores.hangman) highScores.hangman = hangman.streak;
                } else if (game === 'minesweeper' || game === 'sudoku' || game === 'wordsearch') {
                    if (score < highScores[game] || highScores[game] === 999) {
                        highScores[game] = score;
                    }
                } else if (!highScores[game] || score > highScores[game]) {
                    highScores[game] = score;
                }
                localStorage.setItem('gameHighScores', JSON.stringify(highScores));
                updateHighScores();
            } catch (e) {
                console.error('Failed to save high score:', e);
            }
        }

        // === XO GAME ===
        function initXO() {
            xo.board = Array(9).fill('');
            xo.turn = 'X';
            xo.winner = null;
            xo.winLine = null;
            xo.moves = 0;
            document.querySelectorAll('#xoGrid .xo-cell').forEach((cell) => {
                cell.textContent = '';
                cell.className = 'xo-cell';
            });
            document.getElementById('xoStatus').textContent = "X's TURN";
        }

        function playXO(i) {
            if (xo.board[i] !== '' || xo.winner) return;
            
            xo.board[i] = xo.turn;
            xo.moves++;
            const cell = document.querySelector(`#xoGrid .xo-cell:nth-child(${i+1})`);
            cell.textContent = xo.turn;
            cell.classList.add(xo.turn.toLowerCase());
            playSound('move');
            
            const winner = checkWinner();
            if (winner) {
                xo.winner = winner;
                xo.winLine = getWinLine();
                showWinLine();
                document.getElementById('xoStatus').innerHTML = `${winner} <span style="color:#FFD700">WINS! üéâ</span>`;
                document.querySelectorAll('#xoGrid .xo-cell').forEach(c => c.classList.add('game-over'));
                playSound('win');
                saveHighScore('xo', 0);
                return;
            }
            
            xo.turn = xo.turn === 'X' ? 'O' : 'X';
            document.getElementById('xoStatus').textContent = `${xo.turn}'s TURN`;
            
            if (xo.moves >= 9) {
                document.getElementById('xoStatus').innerHTML = 'DRAW! ü§ù';
                document.querySelectorAll('#xoGrid .xo-cell').forEach(c => c.classList.add('game-over'));
            }
        }

        function checkWinner() {
            const wins = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
            for (let win of wins) {
                if (xo.board[win[0]] && xo.board[win[0]] === xo.board[win[1]] && 
                    xo.board[win[0]] === xo.board[win[2]]) return xo.board[win[0]];
            }
            return null;
        }

        function getWinLine() {
            const wins = [
                {indices: [0,1,2], transform: 'translate(-50%, -50%) rotate(0deg)', width: '320px', top: '16.66%', left: '50%'},
                {indices: [3,4,5], transform: 'translate(-50%, -50%) rotate(0deg)', width: '320px', top: '50%', left: '50%'},
                {indices: [6,7,8], transform: 'translate(-50%, -50%) rotate(0deg)', width: '320px', top: '83.33%', left: '50%'},
                {indices: [0,3,6], transform: 'translate(-50%, -50%) rotate(90deg)', width: '320px', top: '50%', left: '16.66%'},
                {indices: [1,4,7], transform: 'translate(-50%, -50%) rotate(90deg)', width: '320px', top: '50%', left: '50%'},
                {indices: [2,5,8], transform: 'translate(-50%, -50%) rotate(90deg)', width: '320px', top: '50%', left: '83.33%'},
                {indices: [0,4,8], transform: 'translate(-50%, -50%) rotate(45deg)', width: '450px', top: '50%', left: '50%'},
                {indices: [2,4,6], transform: 'translate(-50%, -50%) rotate(-45deg)', width: '450px', top: '50%', left: '50%'}
            ];
            return wins.find(win => xo.board[win.indices[0]] === xo.winner);
        }

        function showWinLine() {
            if (!xo.winLine) return;
            
            const grid = document.getElementById('xoGrid');
            const existingLine = grid.querySelector('.win-line');
            if (existingLine) existingLine.remove();
            
            const line = document.createElement('div');
            line.className = `win-line ${xo.winner.toLowerCase()} animate`;
            line.style.cssText = `
                width: ${xo.winLine.width};
                transform: ${xo.winLine.transform};
                top: ${xo.winLine.top};
                left: ${xo.winLine.left};
                margin-top: -4px;
            `;
            grid.appendChild(line);
        }

        function resetXO() { 
            const existingLine = document.querySelector('.win-line');
            if (existingLine) existingLine.remove();
            initXO(); 
        }

        // === SNAKE GAME ===
        function initSnake() {
            snake.x = 20; snake.y = 20; snake.dx = 1; snake.dy = 0;
            snake.cells = [{x:20,y:20},{x:19,y:20},{x:18,y:20}];
            snake.maxCells = 4; snake.score = 0;
            spawnFood();
            document.getElementById('snakeScore').textContent = 'SCORE: 0';
            if (snakeInterval) clearInterval(snakeInterval);
            // Made snake slower - changed from 100ms to 150ms
            snakeInterval = setInterval(snakeLoop, 150);
        }

        function spawnFood() {
            const emptyCells = [];
            for (let x = 1; x <= 38; x++) {
                for (let y = 1; y <= 38; y++) {
                    if (!snake.cells.some(cell => cell.x === x && cell.y === y)) {
                        emptyCells.push({x, y});
                    }
                }
            }
            
            if (emptyCells.length > 0) {
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                snake.foodX = randomCell.x;
                snake.foodY = randomCell.y;
            }
        }

        document.addEventListener('keydown', (e) => {
            if (currentGame === 'snake') {
                if (e.key === 'ArrowUp' && snake.dy !== 1) { snake.dx = 0; snake.dy = -1; }
                if (e.key === 'ArrowDown' && snake.dy !== -1) { snake.dx = 0; snake.dy = 1; }
                if (e.key === 'ArrowLeft' && snake.dx !== 1) { snake.dx = -1; snake.dy = 0; }
                if (e.key === 'ArrowRight' && snake.dx !== -1) { snake.dx = 1; snake.dy = 0; }
            }
        });

        function snakeLoop() {
            if (currentGame !== 'snake') return;

            snake.x += snake.dx;
            snake.y += snake.dy;

            if (snake.x < 1 || snake.x > 38 || snake.y < 1 || snake.y > 38) {
                playSound('gameOver');
                const message = `GAME OVER! Score: ${snake.score}${snake.score > highScores.snake ? ' üéâ NEW HIGH!' : ''}`;
                showModal('Game Over', message);
                saveHighScore('snake', snake.score);
                initSnake();
                return;
            }

            const head = {x: snake.x, y: snake.y};
            snake.cells.unshift(head);

            for (let i = 1; i < snake.cells.length; i++) {
                if (snake.x === snake.cells[i].x && snake.y === snake.cells[i].y) {
                    playSound('gameOver');
                    const message = `GAME OVER! Score: ${snake.score}${snake.score > highScores.snake ? ' üéâ NEW HIGH!' : ''}`;
                    showModal('Game Over', message);
                    saveHighScore('snake', snake.score);
                    initSnake();
                    return;
                }
            }

            if (snake.x === snake.foodX && snake.y === snake.foodY) {
                snake.maxCells++;
                snake.score += 10;
                playSound('score');
                spawnFood();
                document.getElementById('snakeScore').textContent = 'SCORE: ' + snake.score;
            } else {
                while (snake.cells.length > snake.maxCells) {
                    snake.cells.pop();
                }
            }

            const canvas = document.getElementById('snakeCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 400, 400);

            ctx.shadowBlur = 10;
            snake.cells.forEach((cell, i) => {
                ctx.fillStyle = i === 0 ? '#8B4513' : '#27ae60';
                ctx.shadowColor = i === 0 ? '#A0522D' : '#2ecc71';
                ctx.fillRect(cell.x * 10, cell.y * 10, 9, 9);
            });
            ctx.shadowBlur = 0;

            ctx.shadowBlur = 15; ctx.shadowColor = '#dc2626';
            ctx.fillStyle = '#dc2626';
            ctx.fillRect(snake.foodX * 10, snake.foodY * 10, 9, 9);
            ctx.shadowBlur = 0;
        }

        // === MEMORY GAME ===
        function setDifficulty(diff) {
            memoryDifficulty = diff;
            memory.difficulty = diff;
            
            document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            document.getElementById('currentDifficulty').textContent = diff.toUpperCase();
            
            const pairs = {easy:8, medium:9, hard:10};
            memory.totalPairs = pairs[diff];
            document.getElementById('matchGoal').textContent = memory.totalPairs;
            
            document.getElementById('memoryContainer').className = `memory-container ${memoryDifficulty}`;
            
            resetMemory();
        }

        function initMemory() {
            clearInterval(gameTimerInterval);
            memoryStartTime = Date.now();
            memory.flipped = []; 
            memory.matches = 0; 
            memory.isChecking = false;
            
            const emojis = [
                'üçé','üçå','üçá','üçì','üçç','ü•ù','üçí','üçë','üçä','ü•≠','üçà','üçã',
                'üçâ','ü••','ü´ê','üçì','üçí','üçç','ü•ù','üçë'
            ];
            
            const pairs = memoryDifficulty === 'easy' ? 8 : 
                         memoryDifficulty === 'medium' ? 9 : 10;
            
            memory.cards = [];
            for (let i = 0; i < pairs; i++) {
                memory.cards.push(emojis[i], emojis[i]);
            }
            memory.cards.sort(() => Math.random() - 0.5);
            
            document.getElementById('memoryScore').textContent = `MATCHES: 0/${pairs}`;
            document.getElementById('memoryContainer').className = `memory-container ${memoryDifficulty}`;
            document.getElementById('progressFill').style.width = '0%';
            
            gameTimerInterval = setInterval(updateTimer, 1000);
            renderMemory();
        }

        function updateTimer() {
            const elapsed = Math.floor((Date.now() - memoryStartTime) / 1000);
            document.getElementById('gameTimer').textContent = elapsed;
            const progress = (memory.matches / memory.totalPairs) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
        }

        function renderMemory() {
            const grid = document.getElementById('memoryGrid');
            grid.innerHTML = '';
            memory.cards.forEach((emoji, i) => {
                const card = document.createElement('div');
                card.className = 'memory-card';
                card.innerHTML = `
                    <div class="card-face card-back">üß†</div>
                    <div class="card-face card-front">${emoji}</div>
                `;
                card.onclick = () => flipCard(i);
                grid.appendChild(card);
            });
        }

        function flipCard(index) {
            if (memory.flipped.length >= 2 || memory.matches === memory.totalPairs || memory.isChecking) return;
            
            const cards = document.querySelectorAll('#memoryGame .memory-card');
            const card = cards[index];
            
            if (memory.flipped.includes(index)) return;
            
            if (!card.classList.contains('flipped') && !card.classList.contains('matched')) {
                card.classList.add('flipped');
                memory.flipped.push(index);
                playSound('move');
                
                if (memory.flipped.length === 2) {
                    memory.isChecking = true;
                    setTimeout(checkMatch, 1200);
                }
            }
        }

        function checkMatch() {
            const [i1, i2] = memory.flipped;
            const cards = document.querySelectorAll('#memoryGame .memory-card');
            
            if (memory.cards[i1] === memory.cards[i2]) {
                cards[i1].classList.add('matched');
                cards[i2].classList.add('matched');
                memory.matches++;
                playSound('score');
                
                const pairs = memory.totalPairs;
                document.getElementById('memoryScore').textContent = `MATCHES: ${memory.matches}/${pairs}`;
                
                if (memory.matches === pairs) {
                    clearInterval(gameTimerInterval);
                    saveHighScore('memory', 0);
                    const time = Math.floor((Date.now() - memoryStartTime) / 1000);
                    setTimeout(() => {
                        playSound('win');
                        const message = `üéâ PERFECT MEMORY! ${time}s\n${getStarRating(time)}`;
                        showModal('Congratulations!', message);
                    }, 800);
                }
            } else {
                cards[i1].classList.remove('flipped');
                cards[i2].classList.remove('flipped');
                playSound('hit');
            }
            
            memory.flipped = [];
            memory.isChecking = false;
        }

        function giveHint() {
            const unflipped = document.querySelectorAll('#memoryGame .memory-card:not(.flipped):not(.matched)');
            if (unflipped.length === 0) return;
            
            const randomCard = unflipped[Math.floor(Math.random() * unflipped.length)];
            randomCard.classList.add('hint');
            playSound('score');
            
            setTimeout(() => {
                randomCard.classList.remove('hint');
            }, 1500);
        }

        function getStarRating(time) {
            const base = memory.totalPairs * 10;
            if (time <= base) return '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê PERFECT!';
            if (time <= base * 1.5) return '‚≠ê‚≠ê‚≠ê‚≠ê GREAT!';
            if (time <= base * 2) return '‚≠ê‚≠ê‚≠ê GOOD!';
            return '‚≠ê WELL DONE!';
        }

        function resetMemory() { 
            clearInterval(gameTimerInterval);
            initMemory(); 
        }

        // === BREAKOUT GAME ===
        function initBreakout() {
            breakout.score = 0;
            breakout.lives = 3;
            breakout.gameRunning = true;
            breakout.paused = false;
            breakout.paddle.x = 250;
            breakout.paddle.y = 360;
            
            breakout.bricks = [];
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57'];
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 8; col++) {
                    breakout.bricks.push({
                        x: col * 70 + 30, y: row * 30 + 50,
                        width: 65, height: 25, color: colors[row], alive: true
                    });
                }
            }
            
            document.getElementById('breakoutScore').textContent = 'SCORE: 0 | LIVES: 3';
            if (breakoutInterval) clearInterval(breakoutInterval);
            breakoutInterval = setInterval(breakoutLoop, 16);
        }

        document.getElementById('breakoutCanvas').addEventListener('mousemove', (e) => {
            if (currentGame === 'breakout' && breakout.gameRunning) {
                const rect = e.target.getBoundingClientRect();
                breakout.paddle.x = e.clientX - rect.left - breakout.paddle.width / 2;
                if (breakout.paddle.x < 0) breakout.paddle.x = 0;
                if (breakout.paddle.x > 500) breakout.paddle.x = 500;
            }
        });

        document.addEventListener('keydown', (e) => {
            if (currentGame === 'breakout' && e.key === ' ') {
                e.preventDefault();
                breakout.paused = !breakout.paused;
            }
        });

        function breakoutLoop() {
            if (currentGame !== 'breakout' || !breakout.gameRunning || breakout.paused) return;

            const canvas = document.getElementById('breakoutCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 600, 400);

            breakout.bricks.forEach(brick => {
                if (brick.alive) {
                    ctx.fillStyle = brick.color;
                    ctx.shadowBlur = 10; ctx.shadowColor = brick.color;
                    ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                    ctx.shadowBlur = 0;
                }
            });

            breakout.ball.x += breakout.ball.dx;
            breakout.ball.y += breakout.ball.dy;

            if (breakout.ball.x + breakout.ball.radius > 600 || breakout.ball.x - breakout.ball.radius < 0) {
                breakout.ball.dx *= -1;
                playSound('hit');
            }
            if (breakout.ball.y - breakout.ball.radius < 0) {
                breakout.ball.dy *= -1;
                playSound('hit');
            }

            if (breakout.ball.y + breakout.ball.radius > breakout.paddle.y &&
                breakout.ball.y - breakout.ball.radius < breakout.paddle.y + breakout.paddle.height &&
                breakout.ball.x > breakout.paddle.x && 
                breakout.ball.x < breakout.paddle.x + breakout.paddle.width) {
                
                const hitPos = (breakout.ball.x - (breakout.paddle.x + breakout.paddle.width / 2)) / (breakout.paddle.width / 2);
                breakout.ball.dx = hitPos * 5;
                breakout.ball.dy = -Math.abs(breakout.ball.dy);
                playSound('hit');
            }

            if (breakout.ball.y > 400) {
                breakout.lives--;
                playSound('gameOver');
                if (breakout.lives <= 0) {
                    const message = `GAME OVER! Score: ${breakout.score}${breakout.score > highScores.breakout ? ' üéâ NEW HIGH!' : ''}`;
                    showModal('Game Over', message);
                    saveHighScore('breakout', breakout.score);
                    initBreakout();
                    return;
                }
                breakout.ball.x = 300; breakout.ball.y = 200;
                breakout.ball.dx = 4; breakout.ball.dy = -4;
                breakout.paused = true;
                setTimeout(() => breakout.paused = false, 800);
                document.getElementById('breakoutScore').textContent = `SCORE: ${breakout.score} | LIVES: ${breakout.lives}`;
                return;
            }

            for (let i = breakout.bricks.length - 1; i >= 0; i--) {
                const brick = breakout.bricks[i];
                if (brick.alive && 
                    breakout.ball.x > brick.x && breakout.ball.x < brick.x + brick.width &&
                    breakout.ball.y > brick.y && breakout.ball.y < brick.y + brick.height) {
                    brick.alive = false;
                    breakout.score += 10;
                    breakout.ball.dy *= -1;
                    playSound('score');
                    break;
                }
            }

            ctx.fillStyle = '#4CAF50'; ctx.shadowBlur = 15; ctx.shadowColor = '#4CAF50';
            ctx.fillRect(breakout.paddle.x, breakout.paddle.y, breakout.paddle.width, breakout.paddle.height);
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#FFD700'; ctx.shadowBlur = 20; ctx.shadowColor = '#FFD700';
            ctx.beginPath();
            ctx.arc(breakout.ball.x, breakout.ball.y, breakout.ball.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            const aliveBricks = breakout.bricks.filter(b => b.alive).length;
            if (aliveBricks === 0) {
                playSound('win');
                showModal('Congratulations!', `üéâ YOU WIN! Score: ${breakout.score}`);
                saveHighScore('breakout', breakout.score);
                initBreakout();
                return;
            }

            document.getElementById('breakoutScore').textContent = `SCORE: ${breakout.score} | LIVES: ${breakout.lives}`;
        }

        // === ROCK PAPER SCISSORS ===
        function initRPS() {
            document.getElementById('rpsScore').textContent = `WINS: ${rps.wins} | LOSSES: ${rps.losses} | DRAWS: ${rps.draws}`;
            document.getElementById('rpsStatus').textContent = 'MAKE YOUR CHOICE!';
            document.getElementById('rpsResult').style.display = 'none';
        }

        function playRPS(choice) {
            const choices = ['rock', 'paper', 'scissors'];
            const emojis = {rock: 'ü™®', paper: 'üìÑ', scissors: '‚úÇÔ∏è'};
            const computerChoice = choices[Math.floor(Math.random() * 3)];
            
            document.getElementById('playerChoice').textContent = emojis[choice];
            document.getElementById('computerChoice').textContent = emojis[computerChoice];
            document.getElementById('rpsResult').style.display = 'flex';
            
            let result = '';
            if (choice === computerChoice) {
                result = 'DRAW!';
                rps.draws++;
                rps.streak = 0;
                playSound('hit');
            } else if (
                (choice === 'rock' && computerChoice === 'scissors') ||
                (choice === 'paper' && computerChoice === 'rock') ||
                (choice === 'scissors' && computerChoice === 'paper')
            ) {
                result = 'YOU WIN! üéâ';
                rps.wins++;
                rps.streak++;
                if (rps.streak > rps.maxStreak) rps.maxStreak = rps.streak;
                saveHighScore('rps', rps.streak);
                playSound('win');
            } else {
                result = 'YOU LOSE! üò¢';
                rps.losses++;
                rps.streak = 0;
                playSound('gameOver');
            }
            
            document.getElementById('rpsStatus').textContent = result;
            document.getElementById('rpsScore').textContent = `WINS: ${rps.wins} | LOSSES: ${rps.losses} | DRAWS: ${rps.draws}`;
            updateHighScores();
        }

        function resetRPS() {
            rps.wins = 0; rps.losses = 0; rps.draws = 0; rps.streak = 0;
            initRPS();
        }

        // === SHOOTER GAME ===
        function initShooter() {
            shooter.score = 0;
            shooter.level = 1;
            shooter.bullets = [];
            shooter.enemies = [];
            shooter.gameRunning = true;
            
            document.getElementById('shooterScore').textContent = `SCORE: 0 | LEVEL: 1`;
            
            const canvas = document.getElementById('shooterCanvas');
            canvas.addEventListener('click', shootBullet);
            
            if (shooterInterval) clearInterval(shooterInterval);
            shooterInterval = setInterval(shooterLoop, 1000/60);
        }

        function shootBullet(e) {
            if (!shooter.gameRunning) return;
            
            const canvas = document.getElementById('shooterCanvas');
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const angle = Math.atan2(mouseY - shooter.player.y, mouseX - shooter.player.x);
            
            shooter.bullets.push({
                x: shooter.player.x,
                y: shooter.player.y,
                dx: Math.cos(angle) * 10,
                dy: Math.sin(angle) * 10,
                radius: 5
            });
            playSound('move');
        }

        function spawnEnemy() {
            if (Math.random() < 0.02 + shooter.level * 0.005) {
                shooter.enemies.push({
                    x: Math.random() * 660 + 20,
                    y: -30,
                    width: 40,
                    height: 40,
                    dy: 1 + shooter.level * 0.2,
                    color: `hsl(${Math.random() * 360}, 70%, 50%)`
                });
            }
        }

        function shooterLoop() {
            if (currentGame !== 'shooter' || !shooter.gameRunning) return;
            
            const canvas = document.getElementById('shooterCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 700, 500);
            
            // Draw player
            ctx.fillStyle = '#4CAF50';
            ctx.shadowBlur = 20; ctx.shadowColor = '#4CAF50';
            ctx.fillRect(shooter.player.x - shooter.player.width/2, shooter.player.y - shooter.player.height/2, 
                       shooter.player.width, shooter.player.height);
            ctx.shadowBlur = 0;
            
            // Update and draw bullets
            shooter.bullets = shooter.bullets.filter(bullet => {
                bullet.x += bullet.dx;
                bullet.y += bullet.dy;
                
                ctx.fillStyle = '#FFD700';
                ctx.shadowBlur = 10; ctx.shadowColor = '#FFD700';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                return bullet.x > 0 && bullet.x < 700 && bullet.y > 0 && bullet.y < 500;
            });
            
            // Spawn enemies
            spawnEnemy();
            
            // Update and draw enemies
            shooter.enemies = shooter.enemies.filter(enemy => {
                enemy.y += enemy.dy;
                
                ctx.fillStyle = enemy.color;
                ctx.shadowBlur = 15; ctx.shadowColor = enemy.color;
                ctx.fillRect(enemy.x - enemy.width/2, enemy.y - enemy.height/2, enemy.width, enemy.height);
                ctx.shadowBlur = 0;
                
                // Check collision with bullets
                for (let i = shooter.bullets.length - 1; i >= 0; i--) {
                    const bullet = shooter.bullets[i];
                    if (bullet.x > enemy.x - enemy.width/2 && bullet.x < enemy.x + enemy.width/2 &&
                        bullet.y > enemy.y - enemy.height/2 && bullet.y < enemy.y + enemy.height/2) {
                        shooter.bullets.splice(i, 1);
                        shooter.score += 10;
                        playSound('score');
                        
                        if (shooter.score % 100 === 0) {
                            shooter.level++;
                        }
                        
                        document.getElementById('shooterScore').textContent = `SCORE: ${shooter.score} | LEVEL: ${shooter.level}`;
                        return false;
                    }
                }
                
                // Check collision with player
                if (Math.abs(enemy.x - shooter.player.x) < (enemy.width + shooter.player.width)/2 &&
                    Math.abs(enemy.y - shooter.player.y) < (enemy.height + shooter.player.height)/2) {
                    playSound('gameOver');
                    const message = `GAME OVER! Score: ${shooter.score}${shooter.score > highScores.shooter ? ' üéâ NEW HIGH!' : ''}`;
                    showModal('Game Over', message);
                    saveHighScore('shooter', shooter.score);
                    initShooter();
                    return false;
                }
                
                return enemy.y < 530;
            });
        }

        // === CAR GAME ===
        function initCar() {
            car.x = 175;
            car.y = 350;
            car.speed = 0;
            car.distance = 0;
            car.obstacles = [];
            car.gameRunning = true;
            
            document.getElementById('carScore').textContent = 'DISTANCE: 0m | SPEED: 0km/h';
            
            if (carInterval) clearInterval(carInterval);
            carInterval = setInterval(carLoop, 1000/60);
        }

        function spawnObstacle() {
            if (Math.random() < 0.02 && car.obstacles.length < 5) {
                const lanes = [100, 175, 250];
                car.obstacles.push({
                    x: lanes[Math.floor(Math.random() * 3)],
                    y: -50,
                    width: 40,
                    height: 60,
                    speed: 3 + Math.random() * 2
                });
            }
        }

        document.addEventListener('keydown', (e) => {
            if (currentGame === 'car' && car.gameRunning) {
                if (e.key === 'ArrowLeft' && car.x > 75) {
                    car.x -= 75;
                    playSound('move');
                }
                if (e.key === 'ArrowRight' && car.x < 275) {
                    car.x += 75;
                    playSound('move');
                }
            }
        });

        function carLoop() {
            if (currentGame !== 'car' || !car.gameRunning) return;
            
            const canvas = document.getElementById('carCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 350, 500);
            
            // Draw road
            ctx.fillStyle = '#333';
            ctx.fillRect(50, 0, 250, 500);
            
            // Draw road lines
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 5;
            ctx.setLineDash([20, 20]);
            ctx.beginPath();
            ctx.moveTo(150, 0);
            ctx.lineTo(150, 500);
            ctx.moveTo(250, 0);
            ctx.lineTo(250, 500);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw player car
            ctx.fillStyle = '#4CAF50';
            ctx.shadowBlur = 20; ctx.shadowColor = '#4CAF50';
            ctx.fillRect(car.x - car.width/2, car.y - car.height/2, car.width, car.height);
            ctx.shadowBlur = 0;
            
            // Spawn obstacles
            spawnObstacle();
            
            // Update and draw obstacles
            car.obstacles = car.obstacles.filter(obstacle => {
                obstacle.y += obstacle.speed;
                
                ctx.fillStyle = '#e74c3c';
                ctx.shadowBlur = 15; ctx.shadowColor = '#e74c3c';
                ctx.fillRect(obstacle.x - obstacle.width/2, obstacle.y - obstacle.height/2, 
                           obstacle.width, obstacle.height);
                ctx.shadowBlur = 0;
                
                // Check collision
                if (Math.abs(obstacle.x - car.x) < (obstacle.width + car.width)/2 &&
                    Math.abs(obstacle.y - car.y) < (obstacle.height + car.height)/2) {
                    playSound('gameOver');
                    const message = `CRASH! Distance: ${car.distance}m${car.distance > highScores.car ? ' üéâ NEW HIGH!' : ''}`;
                    showModal('Game Over', message);
                    saveHighScore('car', car.distance);
                    initCar();
                    return false;
                }
                
                return obstacle.y < 550;
            });
            
            // Update distance and speed
            car.distance += Math.floor(car.speed);
            car.speed = Math.min(car.speed + 0.01, car.maxSpeed);
            
            document.getElementById('carScore').textContent = `DISTANCE: ${car.distance}m | SPEED: ${Math.floor(car.speed * 20)}km/h`;
        }

        // === PONG GAME ===
        function initPong() {
            pong.ball = { x: 300, y: 200, dx: 4, dy: 3, radius: 8 };
            pong.playerPaddle = { x: 30, y: 150, width: 15, height: 100, dy: 0 };
            pong.computerPaddle = { x: 555, y: 150, width: 15, height: 100, dy: 0 };
            pong.playerScore = 0;
            pong.computerScore = 0;
            pong.gameRunning = true;
            
            document.getElementById('pongScore').textContent = 'PLAYER: 0 | COMPUTER: 0';
            
            const canvas = document.getElementById('pongCanvas');
            canvas.addEventListener('mousemove', (e) => {
                if (currentGame === 'pong' && pong.gameRunning) {
                    const rect = canvas.getBoundingClientRect();
                    pong.playerPaddle.y = e.clientY - rect.top - pong.playerPaddle.height / 2;
                    if (pong.playerPaddle.y < 0) pong.playerPaddle.y = 0;
                    if (pong.playerPaddle.y > 300) pong.playerPaddle.y = 300;
                }
            });
            
            if (pongInterval) clearInterval(pongInterval);
            pongInterval = setInterval(pongLoop, 1000/60);
        }

        document.addEventListener('keydown', (e) => {
            if (currentGame === 'pong' && pong.gameRunning) {
                if (e.key === 'w' || e.key === 'W') pong.playerPaddle.dy = -5;
                if (e.key === 's' || e.key === 'S') pong.playerPaddle.dy = 5;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (currentGame === 'pong') {
                if (e.key === 'w' || e.key === 'W' || e.key === 's' || e.key === 'S') {
                    pong.playerPaddle.dy = 0;
                }
            }
        });

        function pongLoop() {
            if (currentGame !== 'pong' || !pong.gameRunning) return;
            
            const canvas = document.getElementById('pongCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 600, 400);
            
            // Update player paddle
            pong.playerPaddle.y += pong.playerPaddle.dy;
            if (pong.playerPaddle.y < 0) pong.playerPaddle.y = 0;
            if (pong.playerPaddle.y > 300) pong.playerPaddle.y = 300;
            
            // Update computer paddle AI
            const paddleCenter = pong.computerPaddle.y + pong.computerPaddle.height / 2;
            if (paddleCenter < pong.ball.y - 35) {
                pong.computerPaddle.y += 3;
            } else if (paddleCenter > pong.ball.y + 35) {
                pong.computerPaddle.y -= 3;
            }
            
            // Update ball
            pong.ball.x += pong.ball.dx;
            pong.ball.y += pong.ball.dy;
            
            // Ball collision with top/bottom
            if (pong.ball.y - pong.ball.radius < 0 || pong.ball.y + pong.ball.radius > 400) {
                pong.ball.dy *= -1;
                playSound('hit');
            }
            
            // Ball collision with paddles
            if (pong.ball.x - pong.ball.radius < pong.playerPaddle.x + pong.playerPaddle.width &&
                pong.ball.x + pong.ball.radius > pong.playerPaddle.x &&
                pong.ball.y > pong.playerPaddle.y && 
                pong.ball.y < pong.playerPaddle.y + pong.playerPaddle.height) {
                pong.ball.dx = Math.abs(pong.ball.dx);
                playSound('hit');
            }
            
            if (pong.ball.x + pong.ball.radius > pong.computerPaddle.x &&
                pong.ball.x - pong.ball.radius < pong.computerPaddle.x + pong.computerPaddle.width &&
                pong.ball.y > pong.computerPaddle.y && 
                pong.ball.y < pong.computerPaddle.y + pong.computerPaddle.height) {
                pong.ball.dx = -Math.abs(pong.ball.dx);
                playSound('hit');
            }
            
            // Score
            if (pong.ball.x < 0) {
                pong.computerScore++;
                playSound('gameOver');
                resetBall();
            }
            if (pong.ball.x > 600) {
                pong.playerScore++;
                playSound('score');
                resetBall();
            }
            
            // Draw center line
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(300, 0);
            ctx.lineTo(300, 400);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw paddles
            ctx.fillStyle = '#4CAF50';
            ctx.shadowBlur = 15; ctx.shadowColor = '#4CAF50';
            ctx.fillRect(pong.playerPaddle.x, pong.playerPaddle.y, pong.playerPaddle.width, pong.playerPaddle.height);
            
            ctx.fillStyle = '#e74c3c';
            ctx.shadowBlur = 15; ctx.shadowColor = '#e74c3c';
            ctx.fillRect(pong.computerPaddle.x, pong.computerPaddle.y, pong.computerPaddle.width, pong.computerPaddle.height);
            ctx.shadowBlur = 0;
            
            // Draw ball
            ctx.fillStyle = '#FFD700';
            ctx.shadowBlur = 20; ctx.shadowColor = '#FFD700';
            ctx.beginPath();
            ctx.arc(pong.ball.x, pong.ball.y, pong.ball.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Update score display
            document.getElementById('pongScore').textContent = `PLAYER: ${pong.playerScore} | COMPUTER: ${pong.computerScore}`;
            
            // Check win condition
            if (pong.playerScore >= 5) {
                playSound('win');
                showModal('You Win!', `üéâ You beat computer ${pong.playerScore}-${pong.computerScore}!`);
                saveHighScore('pong', pong.playerScore);
                initPong();
            } else if (pong.computerScore >= 5) {
                playSound('gameOver');
                showModal('Game Over', `Computer wins ${pong.computerScore}-${pong.playerScore}`);
                initPong();
            }
        }

        function resetBall() {
            pong.ball.x = 300;
            pong.ball.y = 200;
            pong.ball.dx = (Math.random() > 0.5 ? 1 : -1) * 4;
            pong.ball.dy = (Math.random() - 0.5) * 6;
        }

        // === TETRIS GAME ===
        function initTetris() {
            tetris.board = Array(20).fill().map(() => Array(10).fill(0));
            tetris.score = 0;
            tetris.lines = 0;
            tetris.gameRunning = true;
            tetris.dropCounter = 0;
            tetris.lastTime = 0;
            spawnTetrisPiece();
            
            document.getElementById('tetrisScore').textContent = 'SCORE: 0 | LINES: 0';
            
            if (tetrisInterval) clearInterval(tetrisInterval);
            tetrisInterval = setInterval(tetrisLoop, 1000/60);
        }

        function spawnTetrisPiece() {
            const pieceIndex = Math.floor(Math.random() * tetrisPieces.length);
            tetris.currentPiece = tetrisPieces[pieceIndex];
            tetris.currentX = Math.floor((10 - tetris.currentPiece[0].length) / 2);
            tetris.currentY = 0;
            
            if (collision()) {
                playSound('gameOver');
                const message = `GAME OVER! Score: ${tetris.score}${tetris.score > highScores.tetris ? ' üéâ NEW HIGH!' : ''}`;
                showModal('Game Over', message);
                saveHighScore('tetris', tetris.score);
                initTetris();
            }
        }

        function collision() {
            for (let y = 0; y < tetris.currentPiece.length; y++) {
                for (let x = 0; x < tetris.currentPiece[y].length; x++) {
                    if (tetris.currentPiece[y][x]) {
                        const boardX = tetris.currentX + x;
                        const boardY = tetris.currentY + y;
                        
                        if (boardX < 0 || boardX >= 10 || boardY >= 20) {
                            return true;
                        }
                        
                        if (boardY >= 0 && tetris.board[boardY][boardX]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function merge() {
            for (let y = 0; y < tetris.currentPiece.length; y++) {
                for (let x = 0; x < tetris.currentPiece[y].length; x++) {
                    if (tetris.currentPiece[y][x]) {
                        tetris.board[tetris.currentY + y][tetris.currentX + x] = 1;
                    }
                }
            }
        }

        function rotate() {
            const rotated = tetris.currentPiece[0].map((_, i) =>
                tetris.currentPiece.map(row => row[i]).reverse()
            );
            
            const previousPiece = tetris.currentPiece;
            tetris.currentPiece = rotated;
            
            if (collision()) {
                tetris.currentPiece = previousPiece;
            } else {
                playSound('move');
            }
        }

        function clearLines() {
            let linesCleared = 0;
            
            for (let y = tetris.board.length - 1; y >= 0; y--) {
                if (tetris.board[y].every(cell => cell)) {
                    tetris.board.splice(y, 1);
                    tetris.board.unshift(Array(10).fill(0));
                    linesCleared++;
                    y++;
                }
            }
            
            if (linesCleared > 0) {
                tetris.lines += linesCleared;
                tetris.score += linesCleared * 100;
                playSound('score');
                document.getElementById('tetrisScore').textContent = `SCORE: ${tetris.score} | LINES: ${tetris.lines}`;
            }
        }

        function tetrisLoop(time = 0) {
            if (currentGame !== 'tetris' || !tetris.gameRunning) return;
            
            const deltaTime = time - tetris.lastTime;
            tetris.lastTime = time;
            
            tetris.dropCounter += deltaTime;
            if (tetris.dropCounter > 1000) {
                tetris.currentY++;
                if (collision()) {
                    tetris.currentY--;
                    merge();
                    clearLines();
                    spawnTetrisPiece();
                }
                tetris.dropCounter = 0;
            }
            
            // Draw
            const canvas = document.getElementById('tetrisCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 300, 600);
            
            // Draw board
            ctx.fillStyle = '#333';
            ctx.fillRect(0, 0, 300, 600);
            
            // Draw grid
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= 10; x++) {
                ctx.beginPath();
                ctx.moveTo(x * 30, 0);
                ctx.lineTo(x * 30, 600);
                ctx.stroke();
            }
            for (let y = 0; y <= 20; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * 30);
                ctx.lineTo(300, y * 30);
                ctx.stroke();
            }
            
            // Draw placed pieces
            ctx.fillStyle = '#4CAF50';
            ctx.shadowBlur = 10; ctx.shadowColor = '#4CAF50';
            for (let y = 0; y < 20; y++) {
                for (let x = 0; x < 10; x++) {
                    if (tetris.board[y][x]) {
                        ctx.fillRect(x * 30 + 1, y * 30 + 1, 28, 28);
                    }
                }
            }
            
            // Draw current piece
            ctx.fillStyle = '#FFD700';
            ctx.shadowBlur = 15; ctx.shadowColor = '#FFD700';
            for (let y = 0; y < tetris.currentPiece.length; y++) {
                for (let x = 0; x < tetris.currentPiece[y].length; x++) {
                    if (tetris.currentPiece[y][x]) {
                        ctx.fillRect((tetris.currentX + x) * 30 + 1, (tetris.currentY + y) * 30 + 1, 28, 28);
                    }
                }
            }
            ctx.shadowBlur = 0;
            
            requestAnimationFrame(tetrisLoop);
        }

        document.addEventListener('keydown', (e) => {
            if (currentGame === 'tetris' && tetris.gameRunning) {
                if (e.key === 'ArrowLeft') {
                    tetris.currentX--;
                    if (collision()) tetris.currentX++;
                    else playSound('move');
                }
                if (e.key === 'ArrowRight') {
                    tetris.currentX++;
                    if (collision()) tetris.currentX--;
                    else playSound('move');
                }
                if (e.key === 'ArrowDown') {
                    tetris.currentY++;
                    if (collision()) {
                        tetris.currentY--;
                        merge();
                        clearLines();
                        spawnTetrisPiece();
                    }
                    playSound('move');
                }
                if (e.key === 'ArrowUp') {
                    rotate();
                }
            }
        });

        // === FLAPPY BIRD GAME ===
        function initFlappy() {
            flappy.bird = { x: 100, y: 300, velocity: 0, radius: 15 };
            flappy.pipes = [];
            flappy.score = 0;
            flappy.gameRunning = false;
            flappy.gameStarted = false;
            
            document.getElementById('flappyScore').textContent = 'SCORE: 0';
            document.getElementById('flappyGameOver').style.display = 'none';
            
            const canvas = document.getElementById('flappyCanvas');
            canvas.addEventListener('click', () => {
                if (!flappy.gameStarted) {
                    startFlappyGame();
                } else if (flappy.gameRunning) {
                    jump();
                }
            });
            canvas.addEventListener('touchstart', () => {
                if (!flappy.gameStarted) {
                    startFlappyGame();
                } else if (flappy.gameRunning) {
                    jump();
                }
            });
            
            if (flappyInterval) clearInterval(flappyInterval);
            flappyInterval = setInterval(flappyLoop, 1000/60);
        }

        function startFlappyGame() {
            flappy.bird = { x: 100, y: 300, velocity: 0, radius: 15 };
            flappy.pipes = [];
            flappy.score = 0;
            flappy.gameRunning = true;
            flappy.gameStarted = true;
            
            document.getElementById('flappyScore').textContent = 'SCORE: 0';
            document.getElementById('flappyGameOver').style.display = 'none';
            
            playSound('score');
        }

        function jump() {
            if (currentGame === 'flappy' && flappy.gameRunning) {
                flappy.bird.velocity = -6; // Made jump stronger for easier gameplay
                playSound('jump');
            }
        }

        function spawnPipe() {
            if (flappy.pipes.length === 0 || flappy.pipes[flappy.pipes.length - 1].x < 250) {
                const gap = 180; // Made gap larger for easier gameplay
                const minHeight = 50;
                const maxHeight = 350;
                const height = Math.random() * (maxHeight - minHeight) + minHeight;
                
                flappy.pipes.push({
                    x: 400,
                    topHeight: height,
                    bottomY: height + gap,
                    width: 60,
                    passed: false
                });
            }
        }

        function flappyLoop() {
            if (currentGame !== 'flappy') return;
            
            const canvas = document.getElementById('flappyCanvas');
            const ctx = canvas.getContext('2d');
            
            // Clear and draw background
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, 400, 600);
            
            if (!flappy.gameStarted) {
                // Draw start message
                ctx.fillStyle = '#333';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Click to Start!', 200, 300);
                return;
            }
            
            if (!flappy.gameRunning) return;
            
            // Update bird physics
            flappy.bird.velocity += 0.4; // Reduced gravity for easier gameplay
            flappy.bird.y += flappy.bird.velocity;
            
            // Draw bird
            ctx.fillStyle = '#FFD700';
            ctx.shadowBlur = 15; ctx.shadowColor = '#FFD700';
            ctx.beginPath();
            ctx.arc(flappy.bird.x, flappy.bird.y, flappy.bird.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Spawn pipes
            spawnPipe();
            
            // Update and draw pipes
            flappy.pipes = flappy.pipes.filter(pipe => {
                pipe.x -= 2; // Made pipes move slower for easier gameplay
                
                // Draw pipes
                ctx.fillStyle = '#228B22';
                ctx.shadowBlur = 10; ctx.shadowColor = '#228B22';
                
                // Top pipe
                ctx.fillRect(pipe.x, 0, pipe.width, pipe.topHeight);
                // Bottom pipe
                ctx.fillRect(pipe.x, pipe.bottomY, pipe.width, 600 - pipe.bottomY);
                ctx.shadowBlur = 0;
                
                // Check collision
                if (flappy.bird.x + flappy.bird.radius > pipe.x &&
                    flappy.bird.x - flappy.bird.radius < pipe.x + pipe.width) {
                    if (flappy.bird.y - flappy.bird.radius < pipe.topHeight ||
                        flappy.bird.y + flappy.bird.radius > pipe.bottomY) {
                        endFlappyGame();
                        return false;
                    }
                }
                
                // Score
                if (!pipe.passed && pipe.x + pipe.width < flappy.bird.x) {
                    pipe.passed = true;
                    flappy.score++;
                    playSound('score');
                    document.getElementById('flappyScore').textContent = `SCORE: ${flappy.score}`;
                }
                
                return pipe.x > -pipe.width;
            });
            
            // Check boundaries
            if (flappy.bird.y - flappy.bird.radius < 0 || flappy.bird.y + flappy.bird.radius > 600) {
                endFlappyGame();
            }
        }

        function endFlappyGame() {
            flappy.gameRunning = false;
            playSound('gameOver');
            
            document.getElementById('flappyFinalScore').textContent = flappy.score;
            document.getElementById('flappyGameOver').style.display = 'block';
            
            if (flappy.score > highScores.flappy) {
                saveHighScore('flappy', flappy.score);
            }
        }

        // === DINO GAME ===
        function initDino() {
            dino.dino = { x: 50, y: 300, width: 40, height: 50, velocity: 0, jumping: false };
            dino.obstacles = [];
            dino.score = 0;
            dino.gameRunning = true;
            dino.speed = 5;
            
            document.getElementById('dinoScore').textContent = 'SCORE: 0';
            
            const canvas = document.getElementById('dinoCanvas');
            canvas.addEventListener('click', dinoJump);
            canvas.addEventListener('touchstart', dinoJump);
            
            if (dinoInterval) clearInterval(dinoInterval);
            dinoInterval = setInterval(dinoLoop, 1000/60);
        }

        function dinoJump() {
            if (currentGame === 'dino' && dino.gameRunning && !dino.dino.jumping) {
                dino.dino.velocity = dino.jumpPower;
                dino.dino.jumping = true;
                playSound('jump');
            }
        }

        function spawnDinoObstacle() {
            if (Math.random() < 0.02 && (dino.obstacles.length === 0 || dino.obstacles[dino.obstacles.length - 1].x < 600)) {
                const types = ['cactus', 'bird'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                let obstacle = {
                    x: 800,
                    type: type,
                    passed: false
                };
                
                if (type === 'cactus') {
                    obstacle.y = 350;
                    obstacle.width = 30;
                    obstacle.height = 40;
                } else {
                    obstacle.y = Math.random() > 0.5 ? 280 : 320;
                    obstacle.width = 40;
                    obstacle.height = 30;
                }
                
                dino.obstacles.push(obstacle);
            }
        }

        function dinoLoop() {
            if (currentGame !== 'dino' || !dino.gameRunning) return;
            
            const canvas = document.getElementById('dinoCanvas');
            const ctx = canvas.getContext('2d');
            
            // Clear and draw background
            ctx.fillStyle = '#FFF';
            ctx.fillRect(0, 0, 800, 400);
            
            // Draw ground
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 350);
            ctx.lineTo(800, 350);
            ctx.stroke();
            
            // Update dino physics
            if (dino.dino.jumping) {
                dino.dino.velocity += dino.gravity;
                dino.dino.y += dino.dino.velocity;
                
                if (dino.dino.y >= 300) {
                    dino.dino.y = 300;
                    dino.dino.jumping = false;
                    dino.dino.velocity = 0;
                }
            }
            
            // Draw dino
            ctx.fillStyle = '#333';
            ctx.shadowBlur = 10; ctx.shadowColor = '#333';
            ctx.fillRect(dino.dino.x, dino.dino.y, dino.dino.width, dino.dino.height);
            ctx.shadowBlur = 0;
            
            // Spawn obstacles
            spawnDinoObstacle();
            
            // Update and draw obstacles
            dino.obstacles = dino.obstacles.filter(obstacle => {
                obstacle.x -= dino.speed;
                
                // Draw obstacle
                if (obstacle.type === 'cactus') {
                    ctx.fillStyle = '#228B22';
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                } else {
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                }
                
                // Check collision with improved detection
                const dinoLeft = dino.dino.x;
                const dinoRight = dino.dino.x + dino.dino.width;
                const dinoTop = dino.dino.y;
                const dinoBottom = dino.dino.y + dino.dino.height;
                
                const obsLeft = obstacle.x;
                const obsRight = obstacle.x + obstacle.width;
                const obsTop = obstacle.y;
                const obsBottom = obstacle.y + obstacle.height;
                
                if (dinoLeft < obsRight && dinoRight > obsLeft &&
                    dinoTop < obsBottom && dinoBottom > obsTop) {
                    playSound('gameOver');
                    const message = `GAME OVER! Score: ${dino.score}${dino.score > highScores.dino ? ' üéâ NEW HIGH!' : ''}`;
                    showModal('Game Over', message);
                    saveHighScore('dino', dino.score);
                    initDino();
                    return false;
                }
                
                // Score
                if (!obstacle.passed && obstacle.x + obstacle.width < dino.dino.x) {
                    obstacle.passed = true;
                    dino.score++;
                    playSound('score');
                    document.getElementById('dinoScore').textContent = `SCORE: ${dino.score}`;
                    
                    // Increase speed
                    if (dino.score % 10 === 0) {
                        dino.speed += 0.5;
                    }
                }
                
                return obstacle.x > -obstacle.width;
            });
        }

        document.addEventListener('keydown', (e) => {
            if (currentGame === 'flappy' && (e.key === ' ' || e.key === 'Spacebar')) {
                e.preventDefault();
                if (!flappy.gameStarted) {
                    startFlappyGame();
                } else if (flappy.gameRunning) {
                    jump();
                }
            }
            if (currentGame === 'dino' && (e.key === ' ' || e.key === 'Spacebar')) {
                e.preventDefault();
                dinoJump();
            }
        });

        // === 2048 GAME ===
        function init2048() {
            game2048.board = Array(4).fill().map(() => Array(4).fill(0));
            game2048.score = 0;
            game2048.gameRunning = true;
            addNewTile();
            addNewTile();
            render2048();
            document.getElementById('2048Score').textContent = `SCORE: 0 | BEST: ${game2048.best}`;
        }

        function addNewTile() {
            const emptyCells = [];
            for (let y = 0; y < 4; y++) {
                for (let x = 0; x < 4; x++) {
                    if (game2048.board[y][x] === 0) {
                        emptyCells.push({x, y});
                    }
                }
            }
            
            if (emptyCells.length > 0) {
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                game2048.board[randomCell.y][randomCell.x] = Math.random() > 0.9 ? 4 : 2;
            }
        }

        function render2048() {
            const grid = document.getElementById('2048Grid');
            grid.innerHTML = '';
            
            for (let y = 0; y < 4; y++) {
                for (let x = 0; x < 4; x++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile-2048';
                    const value = game2048.board[y][x];
                    
                    if (value > 0) {
                        tile.textContent = value;
                        tile.classList.add(`tile-${value}`);
                    }
                    
                    grid.appendChild(tile);
                }
            }
            
            document.getElementById('2048Score').textContent = `SCORE: ${game2048.score} | BEST: ${game2048.best}`;
        }

        function move2048(direction) {
            if (!game2048.gameRunning) return;
            
            let moved = false;
            const newBoard = game2048.board.map(row => [...row]);
            
            if (direction === 'left') {
                for (let y = 0; y < 4; y++) {
                    const row = newBoard[y].filter(val => val !== 0);
                    for (let x = 0; x < row.length - 1; x++) {
                        if (row[x] === row[x + 1]) {
                            row[x] *= 2;
                            game2048.score += row[x];
                            row.splice(x + 1, 1);
                        }
                    }
                    while (row.length < 4) row.push(0);
                    if (JSON.stringify(row) !== JSON.stringify(game2048.board[y])) moved = true;
                    newBoard[y] = row;
                }
            } else if (direction === 'right') {
                for (let y = 0; y < 4; y++) {
                    const row = newBoard[y].filter(val => val !== 0);
                    for (let x = row.length - 1; x > 0; x--) {
                        if (row[x] === row[x - 1]) {
                            row[x] *= 2;
                            game2048.score += row[x];
                            row.splice(x - 1, 1);
                            x--;
                        }
                    }
                    while (row.length < 4) row.unshift(0);
                    if (JSON.stringify(row) !== JSON.stringify(game2048.board[y])) moved = true;
                    newBoard[y] = row;
                }
            } else if (direction === 'up') {
                for (let x = 0; x < 4; x++) {
                    const column = [];
                    for (let y = 0; y < 4; y++) {
                        if (newBoard[y][x] !== 0) column.push(newBoard[y][x]);
                    }
                    for (let y = 0; y < column.length - 1; y++) {
                        if (column[y] === column[y + 1]) {
                            column[y] *= 2;
                            game2048.score += column[y];
                            column.splice(y + 1, 1);
                        }
                    }
                    while (column.length < 4) column.push(0);
                    for (let y = 0; y < 4; y++) {
                        if (newBoard[y][x] !== column[y]) moved = true;
                        newBoard[y][x] = column[y];
                    }
                }
            } else if (direction === 'down') {
                for (let x = 0; x < 4; x++) {
                    const column = [];
                    for (let y = 0; y < 4; y++) {
                        if (newBoard[y][x] !== 0) column.push(newBoard[y][x]);
                    }
                    for (let y = column.length - 1; y > 0; y--) {
                        if (column[y] === column[y - 1]) {
                            column[y] *= 2;
                            game2048.score += column[y];
                            column.splice(y - 1, 1);
                            y--;
                        }
                    }
                    while (column.length < 4) column.unshift(0);
                    for (let y = 0; y < 4; y++) {
                        if (newBoard[y][x] !== column[y]) moved = true;
                        newBoard[y][x] = column[y];
                    }
                }
            }
            
            if (moved) {
                game2048.board = newBoard;
                addNewTile();
                render2048();
                playSound('move');
                
                if (game2048.score > game2048.best) {
                    game2048.best = game2048.score;
                    saveHighScore('2048', game2048.best);
                }
                
                // Check for 2048
                for (let y = 0; y < 4; y++) {
                    for (let x = 0; x < 4; x++) {
                        if (game2048.board[y][x] === 2048) {
                            playSound('win');
                            showModal('Congratulations!', `üéâ You reached 2048! Score: ${game2048.score}`);
                            game2048.gameRunning = false;
                        }
                    }
                }
                
                // Check for game over
                let hasEmptyCell = false;
                let canMove = false;
                for (let y = 0; y < 4; y++) {
                    for (let x = 0; x < 4; x++) {
                        if (game2048.board[y][x] === 0) hasEmptyCell = true;
                        if (x < 3 && game2048.board[y][x] === game2048.board[y][x + 1]) canMove = true;
                        if (y < 3 && game2048.board[y][x] === game2048.board[y + 1][x]) canMove = true;
                    }
                }
                
                if (!hasEmptyCell && !canMove) {
                    playSound('gameOver');
                    showModal('Game Over', `Final Score: ${game2048.score}`);
                    game2048.gameRunning = false;
                }
            }
        }

        function reset2048() {
            init2048();
        }

        document.addEventListener('keydown', (e) => {
            if (currentGame === '2048' && game2048.gameRunning) {
                if (e.key === 'ArrowLeft') move2048('left');
                if (e.key === 'ArrowRight') move2048('right');
                if (e.key === 'ArrowUp') move2048('up');
                if (e.key === 'ArrowDown') move2048('down');
            }
        });

        // === MINESWEEPER GAME ===
        function initMinesweeper() {
            minesweeper.board = Array(minesweeper.rows).fill().map(() => Array(minesweeper.cols).fill(0));
            minesweeper.revealed = Array(minesweeper.rows).fill().map(() => Array(minesweeper.cols).fill(false));
            minesweeper.flagged = Array(minesweeper.rows).fill().map(() => Array(minesweeper.cols).fill(false));
            minesweeper.mines = [];
            minesweeper.gameOver = false;
            minesweeper.startTime = Date.now();
            
            // Place mines
            let minesPlaced = 0;
            while (minesPlaced < minesweeper.mineCount) {
                const x = Math.floor(Math.random() * minesweeper.cols);
                const y = Math.floor(Math.random() * minesweeper.rows);
                
                if (minesweeper.board[y][x] !== -1) {
                    minesweeper.board[y][x] = -1;
                    minesweeper.mines.push({x, y});
                    minesPlaced++;
                    
                    // Update adjacent cells
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const ny = y + dy;
                            const nx = x + dx;
                            if (ny >= 0 && ny < minesweeper.rows && nx >= 0 && nx < minesweeper.cols && minesweeper.board[ny][nx] !== -1) {
                                minesweeper.board[ny][nx]++;
                            }
                        }
                    }
                }
            }
            
            renderMinesweeper();
            updateMinesweeperScore();
        }

        function renderMinesweeper() {
            const grid = document.getElementById('minesweeperGrid');
            grid.innerHTML = '';
            grid.style.gridTemplateColumns = `repeat(${minesweeper.cols}, 35px)`;
            grid.style.gridTemplateRows = `repeat(${minesweeper.rows}, 35px)`;
            
            for (let y = 0; y < minesweeper.rows; y++) {
                for (let x = 0; x < minesweeper.cols; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'mine-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    if (minesweeper.revealed[y][x]) {
                        cell.classList.add('revealed');
                        if (minesweeper.board[y][x] === -1) {
                            cell.classList.add('mine');
                            cell.textContent = 'üí£';
                        } else if (minesweeper.board[y][x] > 0) {
                            cell.classList.add(`count-${minesweeper.board[y][x]}`);
                            cell.textContent = minesweeper.board[y][x];
                        }
                    } else if (minesweeper.flagged[y][x]) {
                        cell.classList.add('flagged');
                        cell.textContent = 'üö©';
                    }
                    
                    cell.addEventListener('click', () => revealCell(x, y));
                    cell.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        toggleFlag(x, y);
                    });
                    
                    grid.appendChild(cell);
                }
            }
        }

        function revealCell(x, y) {
            if (minesweeper.gameOver || minesweeper.revealed[y][x] || minesweeper.flagged[y][x]) return;
            
            minesweeper.revealed[y][x] = true;
            
            if (minesweeper.board[y][x] === -1) {
                minesweeper.gameOver = true;
                playSound('gameOver');
                // Reveal all mines
                for (let my = 0; my < minesweeper.rows; my++) {
                    for (let mx = 0; mx < minesweeper.cols; mx++) {
                        if (minesweeper.board[my][mx] === -1) {
                            minesweeper.revealed[my][mx] = true;
                        }
                    }
                }
                renderMinesweeper();
                showModal('Game Over', 'üí£ You hit a mine!');
                return;
            }
            
            playSound('move');
            
            // Auto-reveal adjacent cells if current cell has no mines
            if (minesweeper.board[y][x] === 0) {
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const ny = y + dy;
                        const nx = x + dx;
                        if (ny >= 0 && ny < minesweeper.rows && nx >= 0 && nx < minesweeper.cols) {
                            if (!minesweeper.revealed[ny][nx] && !minesweeper.flagged[ny][nx]) {
                                revealCell(nx, ny);
                            }
                        }
                    }
                }
            }
            
            renderMinesweeper();
            checkMinesweeperWin();
        }

        function toggleFlag(x, y) {
            if (minesweeper.gameOver || minesweeper.revealed[y][x]) return;
            
            minesweeper.flagged[y][x] = !minesweeper.flagged[y][x];
            playSound('move');
            renderMinesweeper();
            updateMinesweeperScore();
        }

        function updateMinesweeperScore() {
            const flagCount = minesweeper.flagged.flat().filter(f => f).length;
            document.getElementById('minesweeperScore').textContent = `MINES: ${minesweeper.mineCount} | FLAGS: ${flagCount}`;
        }

        function checkMinesweeperWin() {
            let won = true;
            for (let y = 0; y < minesweeper.rows; y++) {
                for (let x = 0; x < minesweeper.cols; x++) {
                    if (minesweeper.board[y][x] !== -1 && !minesweeper.revealed[y][x]) {
                        won = false;
                        break;
                    }
                }
            }
            
            if (won) {
                minesweeper.gameOver = true;
                playSound('win');
                const time = Math.floor((Date.now() - minesweeper.startTime) / 1000);
                saveHighScore('minesweeper', time);
                showModal('Congratulations!', `üéâ You won in ${time} seconds!`);
            }
        }

        function resetMinesweeper() {
            initMinesweeper();
        }

        // === SIMON SAYS GAME ===
        function initSimon() {
            simon.sequence = [];
            simon.playerSequence = [];
            simon.level = 0;
            simon.isPlaying = false;
            simon.canClick = false;
            document.getElementById('simonStatus').textContent = 'PRESS START TO BEGIN';
            document.getElementById('simonScore').textContent = `LEVEL: 0 | BEST: ${highScores.simon}`;
        }

        function startSimon() {
            simon.sequence = [];
            simon.playerSequence = [];
            simon.level = 0;
            simon.isPlaying = true;
            nextSimonLevel();
        }

        function nextSimonLevel() {
            simon.playerSequence = [];
            simon.level++;
            document.getElementById('simonScore').textContent = `LEVEL: ${simon.level} | BEST: ${highScores.simon}`;
            document.getElementById('simonStatus').textContent = 'Watch sequence...';
            
            const colors = ['red', 'blue', 'green', 'yellow'];
            const randomColor = colors[Math.floor(Math.random() * 4)];
            simon.sequence.push(randomColor);
            
            simon.canClick = false;
            playSimonSequence();
        }

        function playSimonSequence() {
            let index = 0;
            const interval = setInterval(() => {
                if (index >= simon.sequence.length) {
                    clearInterval(interval);
                    simon.canClick = true;
                    document.getElementById('simonStatus').textContent = 'Your turn!';
                    return;
                }
                
                const color = simon.sequence[index];
                const button = document.querySelector(`.simon-${color}`);
                button.classList.add('active');
                playSound('simon');
                
                setTimeout(() => {
                    button.classList.remove('active');
                    index++;
                }, 400);
            }, 600);
        }

        function simonClick(color) {
            if (!simon.canClick || !simon.isPlaying) return;
            
            const button = document.querySelector(`.simon-${color}`);
            button.classList.add('active');
            playSound('simon');
            
            setTimeout(() => {
                button.classList.remove('active');
            }, 200);
            
            simon.playerSequence.push(color);
            
            const currentIndex = simon.playerSequence.length - 1;
            if (simon.playerSequence[currentIndex] !== simon.sequence[currentIndex]) {
                simon.isPlaying = false;
                playSound('gameOver');
                document.getElementById('simonStatus').textContent = `Game Over! You reached level ${simon.level}`;
                if (simon.level > 1) saveHighScore('simon', simon.level - 1);
                return;
            }
            
            if (simon.playerSequence.length === simon.sequence.length) {
                simon.canClick = false;
                playSound('score');
                setTimeout(() => {
                    nextSimonLevel();
                }, 1000);
            }
        }

        // === HANGMAN GAME ===
        function initHangman() {
            hangman.currentWord = hangman.words[Math.floor(Math.random() * hangman.words.length)];
            hangman.guessedLetters = [];
            hangman.wrongGuesses = 0;
            drawHangman();
            updateHangmanDisplay();
            document.getElementById('hangmanScore').textContent = `WINS: ${hangman.wins} | LOSSES: ${hangman.losses}`;
            document.getElementById('hangmanStatus').textContent = 'GUESS THE WORD!';
            
            // Create letter buttons
            const lettersContainer = document.getElementById('hangmanLetters');
            lettersContainer.innerHTML = '';
            for (let i = 65; i <= 90; i++) {
                const letter = String.fromCharCode(i);
                const button = document.createElement('button');
                button.className = 'letter-btn';
                button.textContent = letter;
                button.onclick = () => guessLetter(letter);
                lettersContainer.appendChild(button);
            }
        }

        function guessLetter(letter) {
            if (hangman.guessedLetters.includes(letter)) return;
            
            hangman.guessedLetters.push(letter);
            const button = Array.from(document.querySelectorAll('.letter-btn')).find(btn => btn.textContent === letter);
            button.disabled = true;
            
            if (hangman.currentWord.includes(letter)) {
                playSound('score');
            } else {
                hangman.wrongGuesses++;
                playSound('hit');
            }
            
            drawHangman();
            updateHangmanDisplay();
            checkHangmanGame();
        }

        function updateHangmanDisplay() {
            const wordDisplay = hangman.currentWord.split('').map(letter => 
                hangman.guessedLetters.includes(letter) ? letter : '_'
            ).join(' ');
            document.getElementById('hangmanWord').textContent = wordDisplay;
        }

        function drawHangman() {
            const canvas = document.getElementById('hangmanCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 250, 250);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            
            // Base
            if (hangman.wrongGuesses > 0) {
                ctx.beginPath();
                ctx.moveTo(10, 230);
                ctx.lineTo(150, 230);
                ctx.stroke();
            }
            
            // Pole
            if (hangman.wrongGuesses > 1) {
                ctx.beginPath();
                ctx.moveTo(50, 230);
                ctx.lineTo(50, 20);
                ctx.stroke();
            }
            
            // Top
            if (hangman.wrongGuesses > 2) {
                ctx.beginPath();
                ctx.moveTo(50, 20);
                ctx.lineTo(130, 20);
                ctx.stroke();
            }
            
            // Noose
            if (hangman.wrongGuesses > 3) {
                ctx.beginPath();
                ctx.moveTo(130, 20);
                ctx.lineTo(130, 50);
                ctx.stroke();
            }
            
            // Head
            if (hangman.wrongGuesses > 4) {
                ctx.beginPath();
                ctx.arc(130, 65, 15, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Body
            if (hangman.wrongGuesses > 5) {
                ctx.beginPath();
                ctx.moveTo(130, 80);
                ctx.lineTo(130, 140);
                ctx.stroke();
            }
            
            // Left arm
            if (hangman.wrongGuesses > 6) {
                ctx.beginPath();
                ctx.moveTo(130, 90);
                ctx.lineTo(110, 120);
                ctx.stroke();
            }
            
            // Right arm
            if (hangman.wrongGuesses > 7) {
                ctx.beginPath();
                ctx.moveTo(130, 90);
                ctx.lineTo(150, 120);
                ctx.stroke();
            }
            
            // Left leg
            if (hangman.wrongGuesses > 8) {
                ctx.beginPath();
                ctx.moveTo(130, 140);
                ctx.lineTo(110, 180);
                ctx.stroke();
            }
            
            // Right leg
            if (hangman.wrongGuesses > 9) {
                ctx.beginPath();
                ctx.moveTo(130, 140);
                ctx.lineTo(150, 180);
                ctx.stroke();
            }
        }

        function checkHangmanGame() {
            const won = hangman.currentWord.split('').every(letter => hangman.guessedLetters.includes(letter));
            
            if (won) {
                hangman.wins++;
                hangman.streak++;
                playSound('win');
                document.getElementById('hangmanStatus').textContent = `üéâ YOU WON! The word was ${hangman.currentWord}`;
                saveHighScore('hangman', hangman.streak);
                setTimeout(() => initHangman(), 2000);
            } else if (hangman.wrongGuesses >= 10) {
                hangman.losses++;
                hangman.streak = 0;
                playSound('gameOver');
                document.getElementById('hangmanStatus').textContent = `üíÄ GAME OVER! The word was ${hangman.currentWord}`;
                setTimeout(() => initHangman(), 2000);
            }
            
            document.getElementById('hangmanScore').textContent = `WINS: ${hangman.wins} | LOSSES: ${hangman.losses}`;
        }

        function resetHangman() {
            initHangman();
        }

        // === SUDOKU GAME ===
        function initSudoku() {
            sudoku.board = Array(9).fill().map(() => Array(9).fill(0));
            sudoku.solution = Array(9).fill().map(() => Array(9).fill(0));
            sudoku.selectedCell = null;
            sudoku.mistakes = 0;
            sudoku.startTime = Date.now();
            
            generateSudoku();
            renderSudoku();
            document.getElementById('sudokuScore').textContent = `MISTAKES: 0/3`;
        }

        function generateSudoku() {
            // Simple sudoku generation (not a full valid generator, but good for demo)
            const base = [
                [5,3,4,6,7,8,9,1,2],
                [6,7,2,1,9,5,3,4,8],
                [1,9,8,3,4,2,5,6,7],
                [8,5,9,7,6,1,4,2,3],
                [4,2,6,8,5,3,7,9,1],
                [7,1,3,9,2,4,8,5,6],
                [9,6,1,5,3,7,2,8,4],
                [2,8,7,4,1,9,6,3,5],
                [3,4,5,2,8,6,1,7,9]
            ];
            
            // Copy solution
            for (let y = 0; y < 9; y++) {
                for (let x = 0; x < 9; x++) {
                    sudoku.solution[y][x] = base[y][x];
                }
            }
            
            // Create puzzle by removing some numbers
            for (let y = 0; y < 9; y++) {
                for (let x = 0; x < 9; x++) {
                    if (Math.random() > 0.5) {
                        sudoku.board[y][x] = 0;
                    } else {
                        sudoku.board[y][x] = base[y][x];
                    }
                }
            }
        }

        function renderSudoku() {
            const grid = document.getElementById('sudokuGrid');
            grid.innerHTML = '';
            
            for (let y = 0; y < 9; y++) {
                for (let x = 0; x < 9; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'sudoku-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    if (sudoku.board[y][x] !== 0) {
                        cell.textContent = sudoku.board[y][x];
                        cell.classList.add('fixed');
                    } else if (sudoku.selectedCell && sudoku.selectedCell.x === x && sudoku.selectedCell.y === y) {
                        cell.classList.add('selected');
                    }
                    
                    cell.addEventListener('click', () => selectSudokuCell(x, y));
                    grid.appendChild(cell);
                }
            }
        }

        function selectSudokuCell(x, y) {
            if (sudoku.board[y][x] !== 0) return;
            
            sudoku.selectedCell = {x, y};
            renderSudoku();
        }

        document.addEventListener('keydown', (e) => {
            if (currentGame === 'sudoku' && sudoku.selectedCell && e.key >= '1' && e.key <= '9') {
                const num = parseInt(e.key);
                const {x, y} = sudoku.selectedCell;
                
                if (sudoku.solution[y][x] === num) {
                    sudoku.board[y][x] = num;
                    playSound('score');
                    sudoku.selectedCell = null;
                    renderSudoku();
                    checkSudokuWin();
                } else {
                    sudoku.mistakes++;
                    playSound('hit');
                    document.getElementById('sudokuScore').textContent = `MISTAKES: ${sudoku.mistakes}/3`;
                    
                    if (sudoku.mistakes >= 3) {
                        playSound('gameOver');
                        showModal('Game Over', 'Too many mistakes! Try again.');
                        setTimeout(() => initSudoku(), 2000);
                    }
                }
            }
        });

        function checkSudokuWin() {
            for (let y = 0; y < 9; y++) {
                for (let x = 0; x < 9; x++) {
                    if (sudoku.board[y][x] !== sudoku.solution[y][x]) {
                        return false;
                    }
                }
            }
            
            playSound('win');
            const time = Math.floor((Date.now() - sudoku.startTime) / 1000);
            saveHighScore('sudoku', time);
            showModal('Congratulations!', `üéâ You solved Sudoku in ${time} seconds!`);
        }

        function resetSudoku() {
            initSudoku();
        }

        // === CONNECT FOUR GAME ===
        function initConnect4() {
            connect4.board = Array(6).fill().map(() => Array(7).fill(0));
            connect4.currentPlayer = 1;
            connect4.gameRunning = true;
            renderConnect4();
            document.getElementById('connect4Score').textContent = `RED: ${connect4.redWins} | YELLOW: ${connect4.yellowWins}`;
            document.getElementById('connect4Status').textContent = 'RED\'S TURN';
        }

        function renderConnect4() {
            const grid = document.getElementById('connect4Grid');
            grid.innerHTML = '';
            
            for (let y = 0; y < 6; y++) {
                for (let x = 0; x < 7; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'connect4-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    if (connect4.board[y][x] === 1) {
                        cell.classList.add('player1');
                    } else if (connect4.board[y][x] === 2) {
                        cell.classList.add('player2');
                    }
                    
                    cell.addEventListener('click', () => dropConnect4Piece(x));
                    grid.appendChild(cell);
                }
            }
        }

        function dropConnect4Piece(col) {
            if (!connect4.gameRunning) return;
            
            // Find the lowest empty row in the column
            let row = -1;
            for (let y = 5; y >= 0; y--) {
                if (connect4.board[y][col] === 0) {
                    row = y;
                    break;
                }
            }
            
            if (row === -1) return; // Column is full
            
            connect4.board[row][col] = connect4.currentPlayer;
            playSound('move');
            renderConnect4();
            
            if (checkConnect4Win(row, col)) {
                connect4.gameRunning = false;
                playSound('win');
                const winner = connect4.currentPlayer === 1 ? 'RED' : 'YELLOW';
                if (connect4.currentPlayer === 1) {
                    connect4.redWins++;
                    saveHighScore('connect4', connect4.redWins);
                }
                document.getElementById('connect4Status').textContent = `${winner} WINS! üéâ`;
                document.getElementById('connect4Score').textContent = `RED: ${connect4.redWins} | YELLOW: ${connect4.yellowWins}`;
                setTimeout(() => initConnect4(), 2000);
                return;
            }
            
            // Check for draw
            if (connect4.board[0].every(cell => cell !== 0)) {
                connect4.gameRunning = false;
                document.getElementById('connect4Status').textContent = 'DRAW! ü§ù';
                setTimeout(() => initConnect4(), 2000);
                return;
            }
            
            // Switch player
            connect4.currentPlayer = connect4.currentPlayer === 1 ? 2 : 1;
            const player = connect4.currentPlayer === 1 ? 'RED' : 'YELLOW';
            document.getElementById('connect4Status').textContent = `${player}'S TURN`;
        }

        function checkConnect4Win(row, col) {
            const player = connect4.board[row][col];
            
            // Check horizontal
            let count = 1;
            for (let x = col - 1; x >= 0 && connect4.board[row][x] === player; x--) count++;
            for (let x = col + 1; x < 7 && connect4.board[row][x] === player; x++) count++;
            if (count >= 4) return true;
            
            // Check vertical
            count = 1;
            for (let y = row - 1; y >= 0 && connect4.board[y][col] === player; y--) count++;
            for (let y = row + 1; y < 6 && connect4.board[y][col] === player; y++) count++;
            if (count >= 4) return true;
            
            // Check diagonal (top-left to bottom-right)
            count = 1;
            for (let i = 1; row - i >= 0 && col - i >= 0 && connect4.board[row - i][col - i] === player; i++) count++;
            for (let i = 1; row + i < 6 && col + i < 7 && connect4.board[row + i][col + i] === player; i++) count++;
            if (count >= 4) return true;
            
            // Check diagonal (top-right to bottom-left)
            count = 1;
            for (let i = 1; row - i >= 0 && col + i < 7 && connect4.board[row - i][col + i] === player; i++) count++;
            for (let i = 1; row + i < 6 && col - i >= 0 && connect4.board[row + i][col - i] === player; i++) count++;
            if (count >= 4) return true;
            
            return false;
        }

        function resetConnect4() {
            initConnect4();
        }

        // === WORD SEARCH GAME ===
        function initWordSearch() {
            wordsearch.grid = Array(12).fill().map(() => Array(12).fill(''));
            wordsearch.foundWords = [];
            wordsearch.selecting = false;
            wordsearch.selectedCells = [];
            wordsearch.startTime = Date.now();
            
            // Place words in grid
            placeWordSearchWords();
            fillEmptyCells();
            renderWordSearch();
            renderWordList();
            document.getElementById('wordsearchScore').textContent = `FOUND: 0/${wordsearch.words.length}`;
        }

        function placeWordSearchWords() {
            const directions = [
                {dx: 1, dy: 0},   // horizontal
                {dx: -1, dy: 0},  // horizontal reverse
                {dx: 0, dy: 1},   // vertical
                {dx: 0, dy: -1},  // vertical reverse
                {dx: 1, dy: 1},   // diagonal
                {dx: -1, dy: -1}, // diagonal reverse
                {dx: 1, dy: -1},  // diagonal
                {dx: -1, dy: 1}   // diagonal reverse
            ];
            
            for (const word of wordsearch.words) {
                let placed = false;
                let attempts = 0;
                
                while (!placed && attempts < 100) {
                    const dir = directions[Math.floor(Math.random() * directions.length)];
                    const x = Math.floor(Math.random() * 12);
                    const y = Math.floor(Math.random() * 12);
                    
                    if (canPlaceWord(word, x, y, dir)) {
                        placeWord(word, x, y, dir);
                        placed = true;
                    }
                    attempts++;
                }
            }
        }

        function canPlaceWord(word, x, y, dir) {
            for (let i = 0; i < word.length; i++) {
                const nx = x + dir.dx * i;
                const ny = y + dir.dy * i;
                
                if (nx < 0 || nx >= 12 || ny < 0 || ny >= 12) return false;
                if (wordsearch.grid[ny][nx] !== '' && wordsearch.grid[ny][nx] !== word[i]) return false;
            }
            return true;
        }

        function placeWord(word, x, y, dir) {
            for (let i = 0; i < word.length; i++) {
                const nx = x + dir.dx * i;
                const ny = y + dir.dy * i;
                wordsearch.grid[ny][nx] = word[i];
            }
        }

        function fillEmptyCells() {
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            for (let y = 0; y < 12; y++) {
                for (let x = 0; x < 12; x++) {
                    if (wordsearch.grid[y][x] === '') {
                        wordsearch.grid[y][x] = letters[Math.floor(Math.random() * letters.length)];
                    }
                }
            }
        }

        function renderWordSearch() {
            const grid = document.getElementById('wordsearchGrid');
            grid.innerHTML = '';
            
            for (let y = 0; y < 12; y++) {
                for (let x = 0; x < 12; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'wordsearch-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.textContent = wordsearch.grid[y][x];
                    
                    // Check if this cell is part of a found word
                    let isFound = false;
                    for (const word of wordsearch.foundWords) {
                        if (word.cells.some(c => c.x === x && c.y === y)) {
                            isFound = true;
                            break;
                        }
                    }
                    
                    if (isFound) {
                        cell.classList.add('found');
                    }
                    
                    grid.appendChild(cell);
                }
            }
            
            // Add mouse events for word selection
            let isSelecting = false;
            let selectedCells = [];
            
            grid.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('wordsearch-cell')) {
                    isSelecting = true;
                    selectedCells = [e.target];
                    e.target.classList.add('selecting');
                }
            });
            
            grid.addEventListener('mouseover', (e) => {
                if (isSelecting && e.target.classList.contains('wordsearch-cell')) {
                    if (!selectedCells.includes(e.target)) {
                        selectedCells.push(e.target);
                        e.target.classList.add('selecting');
                    }
                }
            });
            
            grid.addEventListener('mouseup', () => {
                if (isSelecting) {
                    // Check if selected cells form a word
                    const word = selectedCells.map(cell => cell.textContent).join('');
                    const reversedWord = word.split('').reverse().join('');
                    
                    let foundWord = null;
                    for (const w of wordsearch.words) {
                        if (w === word || w === reversedWord) {
                            foundWord = w;
                            break;
                        }
                    }
                    
                    if (foundWord && !wordsearch.foundWords.some(w => w.word === foundWord)) {
                        // Add to found words
                        const cells = selectedCells.map(cell => ({
                            x: parseInt(cell.dataset.x),
                            y: parseInt(cell.dataset.y)
                        }));
                        
                        wordsearch.foundWords.push({
                            word: foundWord,
                            cells: cells
                        });
                        
                        playSound('score');
                        document.getElementById('wordsearchScore').textContent = `FOUND: ${wordsearch.foundWords.length}/${wordsearch.words.length}`;
                        renderWordSearch();
                        renderWordList();
                        
                        // Check if all words are found
                        if (wordsearch.foundWords.length === wordsearch.words.length) {
                            playSound('win');
                            const time = Math.floor((Date.now() - wordsearch.startTime) / 1000);
                            saveHighScore('wordsearch', time);
                            showModal('Congratulations!', `üéâ You found all words in ${time} seconds!`);
                        }
                    } else {
                        // Clear selection
                        selectedCells.forEach(cell => cell.classList.remove('selecting'));
                    }
                    
                    isSelecting = false;
                    selectedCells = [];
                }
            });
        }

        function renderWordList() {
            const list = document.getElementById('wordList');
            list.innerHTML = '';
            
            for (const word of wordsearch.words) {
                const item = document.createElement('div');
                item.className = 'word-item';
                item.textContent = word;
                
                if (wordsearch.foundWords.some(w => w.word === word)) {
                    item.classList.add('found');
                }
                
                list.appendChild(item);
            }
        }

        function resetWordSearch() {
            initWordSearch();
        }

        // Initialize the app
        document.addEventListener('DOMContentLoaded', () => {
            updateHighScores();
        });
    </script>
</body>
</html>